* 
#+latex_header: \usepackage[utf8x]{inputenc}
#+latex_header: \usepackage[T2A]{fontenc}
** Теория
*** Основы объектно-ориентированного программирования
**** Парадигмы программирования, их виды, отличительные особенности.
     1) Парадигмы программирования, их виды, отличительные особенности: 
     Парадигма программирования — это способ классификации языков программирования на основе их возможностей. Есть 4 вида парадигмы: 
	 Императивное программирование (Императивные ЯП ориентированы на операторы): Задают вычисления как последовательность команд. При реализации оператора присваивания происходит передача операндов выражения из памяти в процессор, а результат вычисления выражения заносится в ячейку памяти. Поскольку операторы хранятся в соседних ячейках памяти, то итерации осуществляются очень быстро. Программа состоит из последовательности операторов, выполнение каждого из которых влечет за собой изменение значения ячейках памяти (оператор1; оператор2; …). Операторы выполняются в порядке их следования в программе.
	 Функциональное программирование (Функциональные ЯП задают вычисления как вызовы функций): Ищется функция программы, обеспечивающая ожидаемый результат. Внимание концентрируется на последовательных преобразованиях начальных данных с помощью функций. Как только будет придумана последовательность функций, её можно применить к начальным данным и получить результат (functionn(…function2(function1(данные))…)). Сначала первая потом вторая и так далее. В конце functionn возвращает исходный результат. Чтобы определить функцию, нужно придумать ее имя и задать вычисляемое ей выражение.
	 Логическое программирование (Логические ЯП описывают вычисления с помощью формальной логики): Задают формализованное представление предметной области. Осуществляется проверка некоторого утверждения, и в случае его истинного значения выполняется действие. Тут не существует определенного порядка применения правил, и система реализации языка сама выбирает нужный порядок выполнения действий, который приведет к желаемому результату.
	 Объектно-ориентированное программирование (В объектно-ориентированных ЯП вычисления реализуются совокупностью объектов): Две цели при создании этого вида: 1) Сократить размеры программ (маленькие переменные заменяются большими объектами) тем самым обеспечить возможность создания (за то же время) более крупных программных приложений; 2) Упростить процесс создания новых программ на базе старых (за счет применения механизма наследования). Объект — это именуемый модуль, заключающий в себе данные и операции для их обработки. Объекты взаимодействуют друг с другом с помощью сообщений. Посылается сообщение объектом-источником в адрес объекта-приемника. Каждое сообщение — это запрос на выполнение операции объектом-приемником. В роли описаний для объектов выступают классы. Инкапсуляция - это помещение объекта в оболочку сквозь которую другие объекты видят лишь заголовки операций, которые может выполнять объект. Наследование позволяет внедрить в новый класс элементы данных и операции старого класса. Полиморфизм поддерживает существования целого семейства различных операций с одинаковым именем.
**** Недостатки структурного программирования. Объектно-ориентированный подход, его преимущества, подход к организации программы.
     Как бы эффективно ни применялся структурный подход, он не позволяет в достаточной степени упростить большие сложные программы.
     Со сложностью приложения трудно что-либо сделать — она определяется целью создания программы. А вот сложность реализации можно попытаться контролировать. Первый вопрос, возникающий при декомпозиции: на какие компоненты (модули, функции, классы) нужно разбить программу? Существует две основные проблемы. Первая заключается в неограниченности доступа функций к глобальным данным. Вторая состоит в том, что разделение данных и функций, являющееся основой структурного подхода, плохо отображает картину реального мира. Большие программы обычно содержат множество функций и глобальных переменных. Проблема процедурного подхода заключается в том, что число возможных связей между глобальными переменными и функциями может быть очень велико/ Моделирование реального мира. Вторая заключается в том, что отделение данных от функций оказывается малопригодным для отображения картины реального мира. В реальном мире нам приходится иметь дело с физическими объектами. Эти объекты нельзя отнести ни к данным, ни к функциям, поскольку реальные вещи представляют собой совокупность свойств и поведения.
     Объектно-ориентированный подход Основополагающей идеей объектно-ориентированного подхода является объединение данных и действий, производимых над этими данными, в единое целое, которое называется объектом.
     Функции объекта, называемые в C++ методами или функциями-членами, обычно предназначены для доступа к данным объекта. Если необходимо считать какие-либо данные объекта, нужно вызвать соответствующий метод, который выполнит считывание и возвратит требуемое значение. Прямой доступ к данным невозможен. Данные сокрыты от внешнего воздействия, что защищает их от случайного изменения. Говорят, что данные и методы инкапсулированы. Термины сокрытие и инкапсуляция данных являются ключевыми в описании объектно-ориентированных языков. Доступ к отдельным частям класса регулируется с помощью специальных ключевых слов: public (открытая часть), private (закрытая часть) и protected (защищенная часть). Если необходимо изменить данные объекта, то, очевидно, это действие также будет возложено на методы объекта. Никакие другие функции не могут изменять данные класса. Такой подход облегчает написание, отладку и использование программы.
     ООП: подход к организации программы Объектно-ориентированное программирование никак не связано с процессом выполнения программы, а является лишь способом ее организации. Большая часть операторов C++ идентична операторам процедурных языков, в частности языка С. Только по контексту программы можно определить, является ли функция частью процедурной С-программы или объектно-ориентированной программы на C++.
**** Объектно-ориентированное программирование. Его основные принципы (постулаты).
     Объектно-ориентированное программирование – это методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования. Является техникой программирования.
     Принципы:
     1. Инкапсуляция данных.
     Класс – это производный тип, введенный программистом на основе уже существующих типов. Механизм классов позволяет создавать типы, с наибольшей полнотой отображающие особенности решаемой задачи. Класс задает некоторую структурированную совокупность типизированных данных и позволяет определить набор операций над этими данными. Таким образом, тип, определяемый программистом, ведет себя так же как встроенный. Такой тип часто называют абстрактным типом данных.
     2. Наследование
     Наследование – это использование ранее 
     определенного класса. Язык С++ позволяет классу наследовать данные и функции члены одного или нескольких других классов. Новый класс называют производным классом. Класс, элементы которого наследуются производным классом, называется базовым классом. В свою очередь, производный класс может быть базовым для других классов. Наследование дает возможность абстрагировать некоторое общее или схожее поведение различных объектов в одном базовом классе. Производный класс может переопределить некоторые функции члены базового класса, наследуя тем не менее основной объем свойств и атрибутов базового класса.
     3. Полиморфизм
     Полиморфизм реализуется посредством виртуальных функций. К механизму виртуальных функций обращаются в тех случаях, когда в базовый класс необходимо поместить функцию, которая должна работать по-разному в производных классах, т. е. в каждом классе есть свой вариант этой функции.
**** Понятие класса и объекта. Конструктор, его виды. 
     1. Деструктор.
     2. Виртуальные функции.
     3. Дружественные функции.
     4. Полиморфизм .
     5. Наследование.
     6. Инкапсуляция.
     7. Перегрузка операторов (и функций).
     Класс - это пользовательский тип. Он состоит из встроенных типов, других пользовательских типов и функций. Компоненты, использованные при определении класса, называются его членами. Класс может содержать несколько членов, а может и не иметь ни одного члена. Члены класса могут иметь разные типы. Большинство из них являются либо данными членами, определяющими представление объекта класса.
     Объект — это именуемый модуль, заключающий в себе данные и операции для их обработки
     Конструктор – это функция, не имеющая возвращаемого типа, имя которой совпадает с именем класса. можно сказать, что конструктор — это функция класса, которая совпадает с его именем, не возвращает значения и предназначена для начальной инициализации членов-данных и других действий которые должны выполняться в момент создания объекта.
     Виды: Конструктор по умолчанию не принимает никаких параметров и чаще всего используется для начальной инициализации членов-данных
     Конструктор с параметрами, как можно понять из его названия, принимает параметры, чаще всего используемые для инициализации членов-данных значениями этих переметров.
     Конструктор копирования. конструктор копирования предназначен для копирования объектов.
     Деструктор — противоположность конструктору. Он вызывается в момент «разрушения» объекта, это происходит когда объект выходит за пределы области видимости.
     Виртуальные функции. - функция, которая определяется в базовом классе, а любой порожденный класс может ее переопределить. Виртуальная функция вызывается только через указатель или ссылку на базовый класс.
     Дружественные функции. - функции, которые не являются членами класса, однако имеют доступ к его закрытым членам - переменным и функциям, которые имеют спецификатор private. Для определения дружественных функций используется ключевое слово friend
     Полиморфизм поддерживает возможность существования целого семейства различных операций с одинаковым именем
     Наследование. позволяет внедрить в новый класс элементы данных и операции старого класса, обеспечивая возможность их модификации
     Инкапсуляция. означает, что каждый объект помещен в защитную оболочку, сквозь которую другие объекты видят лишь самое необходимое: заголовки операций, которые может выполнять объект
     Перегрузка операторов (и функций).
     Динамическая идентификация типов.
*** Динамическая идентификация типов.
**** Модификаторы доступа к данным, область видимости, время жизни объекта. Динамические структуры данных
     Модификаторы доступа — специальные зарезервированные слова, которые ограничивают область видимости полей, констант, методов и классов. Модификаторы доступа позволяют ограничить доступ пользователя к отдельным полям и методам объекта. Область видимости переменной, метода или класса – это их свойство быть доступными из тех или иных частей кода, т. е. различных областей программы. Область видимости может определяться как самим местом объявления идентификатора, так и применением к нему модификатора доступа. Время жизни — это интервал выполнения программы, в течение которого программный объект (переменная или функция) существуют — доступна для использования. Время жизни переменной может быть глобальным или локальным. Объект с глобальным временем жизни имеет распределенную для него компилятором память и определенное значение на протяжении всего выполнения программы. Память для локальных переменных выделяется, когда начинается выполнение функции или блока, где они были объявлены. Как только происходит возврат из функции или выход из блока, эта память освобождается локальными переменными, снова становится доступной и может быть использована другими функциями и другими переменными. Под динамической структурой данных понимается любая структура данных, занимаемый объем памяти которой не является фиксированным. Существует несколько разновидностей динамических структур: список, дерево. *** Потомок — элемент структуры, идущий после текущего. В зависимости от вида динамической структуры у элемента может быть более одного потомка. Предок — элемент структуры, идущий до текущего. Головной элемент (Head) — первый элемент списка. Хвостовой элемент (Tail) — последний элемент списка. ***
     Список — это линейная динамическая структура данных, у каждого элемента может быть только один предок и только один потомок. По сути своей это очень похоже на обыкновенный массив, с той лишь разницей, что размер его не имеет ограничений. Списки также подразделяются на несколько типов.
     ● Односвязный список — элемент имеет указатель только на своего потомка.
     ● Двусвязный список — элемент имеет указатели и на потомка, и на родителя.
     ● Замкнутый (кольцевой, циклический) список — головной и хвостовой элементы которого указывают друг на друга.
     На базе простого однонаправленного списка могут быть построены такие структуры данных, как очередь(queue) и стек(stack).
     Дерево в отличие от списка, у одной записи может быть более одного потомка, но только один предок. Кроме того в дереве явно выделяется только головной элемент, называемый корнем (Root). Среди деревьев также существует разбиение на подтипы.
     Бинарное дерево — у каждой вершины дерева может быть не более двух потомков. Сильно разветвленное дерево — у вершины может быть n-ое число потомков.
**** Динамические структуры данных. Примеры, их особенности (не меньше 4х).
     Динамические структуры данных – это структуры данных, память под которые выделяется и освобождается по мере необходимости.
     Односвязные списки
     Очень часто динамическую память используют для создания связанных списков, которые применяются в тех случаях, когда трудно или вообще невозможно предсказать число объектов, обрабатываемых программой, и поэтому традиционные структуры данных, для которых требуется заранее определить максимальное число элементов, не применимы. В подобных ситуациях используются динамические объекты (узлы), которые создаются не заранее, а в моменты, определяемые логикой программы, и объединяются (связываются) с уже существующими объектами с помощью указателей. Начнем рассмотрение с линейных односвязных списков.
     #+begin_src C++ :includes <iostream> 
       struct list * init(int a) // а- значение первого узла
       {
           struct list *lst;
           // выделение памяти под корень списка
           lst = (struct list*)malloc(sizeof(struct list));
           lst->field = a;
           lst->ptr = NULL; // это последний узел списка
           return(lst);
       }
     #+end_src
     Двусвязные списки
     Для построения двусвязных списков используются структуры, имеющие не менее двух полей, содержащих указатели на эту же структуру. На рис. 8 приведен линейный список с двумя связями. Наличие двух связей позволяет перемещаться по списку как слева направо, так и справа налево.
     #+begin_src C++ :includes <iostream> 
       struct list * init(int a)  // а- значение первого узла
       {
           struct list *lst;
           // выделение памяти под корень списка
           lst = (struct list*)malloc(sizeof(struct list));
           lst->field = a;
           lst->next = NULL; // указатель на следующий узел
           lst->prev = NULL; // указатель на предыдущий узел
           return(lst);
       }
     #+end_src
     Двоичное дерево
     Двоичные деревья являются наиболее важными структурами данных, используемых в информатике. Деревья применяются при синтаксическом анализе, поиске, сортировке, управлении базами данных, в игровых алгоритмах и других важных сферах приложений.
     Двоичное дерево - это нелинейный двусвязный список представляющий конечное множество элементов, каждый из которых может быть либо пустым, либо содержать корневой узел и, возможно, другие узлы. Начальная точка двоичного дерева называется корневым узлом. Все остальные узлы можно разделить на два непересекающихся подмножества, каждое из которых само является двоичным деревом. Такие подмножества называются правым и левым поддеревьями. Каждый узел двоичного дерева может иметь 0, 1 или 2 поддерева. Если у узла нет поддеревьев (потомков), то он называется листом. Каждый узел двоичного дерева имеет идентифицирующий его ключ. Такие деревья рисуются по традиции корнем вверх и листьями вниз.
     #+begin_src C++ :includes <iostream> 
       struct tnode {
           int field;           // поле данных
           struct tnode *left;  // левый потомок
           struct tnode *right; // правый потомок
       }
     #+end_src
**** Понятие контейнера. Связный список (два вида). Преимущества и недостатки по отношению к массивам данных.
     Контейнерные классы — это классы, предназначенные для хранения данных, организованных определенным образом. Примерами контейнеров могут служить массивы и линейные списки. Для каждого типа контейнера определены методы для работы с его элементами, не зависящие от конкретного типа данных, которые хранятся в контейнере, поэтому один и тот же вид контейнера можно использовать для хранения данных различных типов.
     Контейнерные классы находятся в STL - Standard Template Library (Стандартная библиотека шаблонов). Особенности контейнеров: Плюсы: повышение надежности программы, их переносимость, универсальность и уменьшение сроков разработки.
     Минусы: медленная программа; для эффективного использования контейнеров нужно затратить усилия на освоение библиотеки.
     Контейнеры можно разделить на два типа: последовательные(1) и ассоциативные(2).
     1) vector, deque (двусторонние очереди), list (список); 2) set, map. Адаптеры (варианты контейнеров): stack, queue (очереди) и priotity_queue.
     Список — это линейная динамическая структура данных, у каждого элемента может быть только один предок и только один потомок. Два вида: Если каждый элемент содержит ссылку на следующий элемент, то такой список называется односвязным. Если добавить в каждый элемент вторую ссылку на предыдущий, получится двусвязный список.
     Преимущества: можно легко вставлять, удалять элементы, сортировать. Для расположения в памяти не требует одного большого куска, а много маленьких, поэтому больше вероятность, что ему памяти хватит.
     Недостатки: требует больше памяти на указатели, доступ к элементам последовательный.
**** Двусвязный список. Его программная реализация. Преимущества и недостатки по отношению к массивам данных.
     Двусвязный список -это структура данных, которая состоит из узлов, которые хранят полезные данные, указатели на предыдущий узел и следующий узел.
     Реализация
     1. Инициализация
     2. Включение до рабочего указателя
     3. Включение после рабочего указателя
     4. Исключение до рабочего указателя
     5. Исключение после рабочего указателя
     6. Сдвиг рабочего указателя назад (к предыдущему элементу)
     7. Сдвиг рабочего указателя вперед (к следующему элементу)
     8. Установка рабочего указателя в начало списка
     9. Установка рабочего указателя в конец списка
     10. Проверка пустоты списка
     11. Удаление списка
     Преимущества и недостатки по отношению к массивам данных.
     Вставка или удаление элемента в определенной точке списка, при условии, что мы уже проиндексировали указатель на узел, является операцией с постоянным временем, тогда как вставка в динамический массив в случайных местах потребует перемещения в среднем половины элементов, а всех элементов в худшем случае.Произвольное количество элементов может быть вставлено в связанный список, ограниченный только общей доступной памятью; в то время как динамический массив в конечном итоге заполнит свою базовую структуру данных массива, и ему придется перераспределять данные (заново выделять память)
     С другой стороны, массивы допускают произвольный доступ за постоянное время, в то время как связанные списки допускают только последовательный доступ к элементам. Другим недостатком связанных списков является дополнительное хранилище, необходимое для ссылок, что часто делает их непрактичными для списков небольших элементов данных, таких как символы или логические значения, поскольку накладные расходы на хранение для ссылок могут превышать в два или более раз размер данных. Напротив, динамический массив требует только места для самих данных. Связанный список также может быть медленным и с наивным распределителем, расточительным, выделяющим память отдельно для каждого нового элемента.
**** Алгоритм (можно словесное поэтапное описание) добавления элемента в двусвязный список (подробный). Алгоритм удаления элемента из двусвязного списка.
     #+begin_src C++ :includes <iostream>
       Node *insert(Node *const first, Node **end, int keyValue, int data)
       {
           Node *keyPointer = find(first, keyValue);
           if (keyPointer)
               {
                   Node *tmp = new Node();
                   tmp->data = data;
                   // 1 – установление связи нового узла с последующим:
                   tmp->next = keyPointer->next;
                   // 2 – установление вязи нового узла с предыдущим:
                   tmp->prev = keyPointer;
                   // 3 – установление связи предыдущего узла с новым:
                   keyPointer->next = tmp;
                   // 4 – установление связи последующего узла с новым:
                   if (keyPointer != *end) (tmp->next)->prev = tmp;
                   //Обновление указателя на конец списка,
                   //если узел вставляется в конец:
                   else *end = tmp;
                   return tmp;
               }
           return 0;
       }
       // Удаление элемента
       bool remove(Node **first, Node **end, int keyValue)
       {
           if (Node *keyPointer = find(*first, keyValue))
               {
                   if (keyPointer == *first)
                       {
                           ,*first = (*first)->next;
                           (*first)->prev = 0;
                       }
                   else if (keyPointer == *end)
                       {
                           ,*end = (*end)->prev; (*end)->next = 0;
                       }
                   else
                       {
                           (keyPointer->prev)->next = keyPointer->next; // 1
                           (keyPointer->next)->prev = keyPointer->prev; // 2
                       }
                   delete keyPointer; // 3
                   return true;
               } return false;
       } 
     #+end_src
**** Контейнерные классы. Преимущества их использования. Контейнер std::vector, его некоторые методы. Стандартная библиотека шаблонов
     Контейнерные классы — это классы, предназначенные для хранения данных, организованных определенным образом. Один и тот же вид контейнера можно использовать для хранения данных различных типов. (Набор значений (объектов) одного или различных типов, хранящихся в контейнере). Массив Многомерный массив Список Стек Очередь Вектор и т.д Плюсы: Гибкость- порядок элементов связного списка может не совпадать с порядком расположения элементов данных в памяти компьютера, а порядок обхода списка всегда явно задаётся его внутренними связями. Удобство(на примере списка)- скорость вставки в произвольную позицию и скорость удаления из произвольной позиции не зависит от количества элементов (быстро). Использование контейнеров позволяет значительно повысить надежность программ, их переносимость и универсальность, а также уменьшить сроки их разработки. Минусы: Универсальность и безопасность использования контейнерных классов не могут не отражаться на быстродействии программы. Снижение быстродействия в зависимости от реализации компилятора может быть весьма значительным. Кроме того, для эффективного использования контейнеров требуется затратить усилия на вдумчивое освоение библиотеки. Вектор — это структура, эффективно реализующая произвольный доступ к элементам, добавление в конец и удаление из конца Size() - Возвращает количество элементов в контейнере swap() - Производит обмен двух контейнеров begin() - Возвращает итератор, ссылающийся на первый элемент контейнера end() - Возвращает итератор, ссылающийся на элемент за пределами контейнера. Также, если нам требуется узнать пуст ли стек, мы можем использовать функцию — empty(). Если нам требуется узнать длину вектора, понадобится функция — size(). Эта функция практически всегда используется вместе с циклом for.С помощью функции push_back() мы можем добавить ячейку в конец вектора. А функция pop_back() все делает наоборот — удаляет одну ячейку в конце вектора. icnert()- добавить ячейку в начало вектора.
**** Обобщенное программирование, понятие шаблона.
     Шаблоны классов и функций.
     Обобщённое программирование — парадигма программирования, заключающаяся в таком описании данных и алгоритмов, которое можно применять к различным типам данных, не меняя само это описание.
     Язык С++ — это компилируемый язык со строгой типизацией, поэтому на этапе выполнения у него нет гибкости интерпретируемых языков, таких как Python, и у каждой функции должны быть строго определённые типы формальных параметров.
     Для того, чтобы не писать много раз повторяющиеся почти дословно описания классов и функций в язык С++ введен механизм шаблонов функций и шаблонов классов.
     Конкретная функция или класс, получаемый по этому шаблону на этапе компиляции, называется специализацией.
     А сам этап компиляции, на котором происходит порождение специализации по шаблону называется инстанцированием.
     Шаблоны классов
     Шаблоны в Си++ создаются с помощью ключевого слова «template»:
     #+begin_src C++ :includes <iostream>
       template <typename T>
       class Container {
       public:
           void add (T value);
           int index_of (T value);
           int get_count ();
           T get_value (int index);
       private:
           //… … …
       };
     #+end_src
     Мы имеем шаблон, называемый «Container». Этим шаблоном, как и любым другим, в чистом виде пользоваться нельзя; пользоваться можно только его экземплярами для конкретных типов.
     В Си++ экземпляр шаблона «Container» для типа «int» будет называться «Container<int>»; угловые скобки и всё между ними следует рассматривать как часть названия класса. (Хотя, безусловно, вы можете вставлять пробелы по вкусу, например «Container < int >».)
     Си++ сам создаёт нужные экземпляры шаблона, то есть никаких «DEFINE_CONTAINER» и тому подобных вещей вы не пишете вообще. Вы просто пользуетесь нужными экземплярами шаблонов. Например, мы можем написать:
     #+begin_src C++ :includes <iostream>
       Container <int> apples;
       int main () {
           apples.add (7);
           apples.add (11);
       }
     #+end_src
     Что ещё нужно вам узнать прямо сейчас?
     · В чистом виде название «Container» не используется почти ни в каких случаях. (Есть исключения) Всегда используется или «template <typename T> class Container», если мы говорим о шаблоне в общем, или же «Container <int>», если мы говорим о конкретном экземпляре шаблона.
     · Безусловно, у шаблонов может быть несколько параметров.
     · Параметрами шаблонов могут быть не только типы. Например, вы можете описать шаблон «template <typename T, unsigned size> class Array», и воспользоваться его экземпляром «Array <float, 20>».
     · Шаблонные классы могут иметь специализации и шаблонные функции-члены. Шаблон класса должен целиком размещаться в одном файле (единице трансляции).
     Шаблоны функций
     Бывает, что нет смысла городить «целый класс», и шаблона одной-единственной функции вам вполне достаточно. Например, напишем функцию «swap», которая меняет местами значения переданных аргументов.
     Вот как она выглядит на Си++:
     #+begin_src C++ :includes <iostream>
       template <typename T>
       void swap (T &left, T &right) {
           T temp = left;
           left = right;
           right = temp;
       }
     #+end_src
     Аналогично шаблонам классов, это — шаблон функции. (Часто говорят — «шаблонный класс», «шаблонная функция».) Экземпляр этой функции, обменивающий местами два значения типа «int», называется «swap <int>».
     Однако, в отличие от классов, при вызове функций обычно предоставляют компилятору право выяснить параметры шаблона. Вот так:
     #+begin_src C++ :includes <iostream> 
       int main () {
           int a = 3, b = 5;
           swap (a, b);
           /* теперь a = 5, b = 3 */
       }
     #+end_src
     Поскольку оба аргумента функции имеют тип «int», компилятор знает, что нужно вызвать «swap <int> (a, b)». Разумеется, всегда можно указать экземпляр функции вручную, самостоятельно вызвав «swap <int> (a, b)».
     Во всём остальном шаблоны функций не отличаются от шаблонов классов.
*** Шаблоны классов и функций.
**** Контейнеры в stl, понятие итератора.
     Итератор – это класс, объекты, которого по отношению к контейнерам играют роль указателей, они, по сути, склеивают ядро STL в одну библиотеку.
     Библиотека стандартных шаблонов (STL) — набор согласованных обобщённых алгоритмов, контейнеров, средств доступа к их содержимому и различных вспомогательных функций в C++.
**** Бинарные файлы. Отличие записи в текстовом и бинарном формате.
     Бинарные файлы могут хранить байты с любыми значениями [0...255]. Бинарные файлы необходимо редактировать в специальных Hex-редакторах. Плюсы и минусы бинарных файлов:
	 Выше скорость загрузки и сохранения данных в бинарном файле.
	 требуется меньший объем дискового пространства для хранения данных.
	 Проблемы с переносимостью на другую платформу.
	 «Закрытость» данных: затруднено редактирование вне приложения.
     Запись бинарных файлов: Записать размер массива, цикл для каждого элемента, записать элемент, конец цикла.
**** Класс std::string. Пример использования. Часто используемые методы при работе с ним.
     Строки STL предусмотрены классы для символьных строк в заголовочном файле. Основным является класс std::string и несколько подобных ему, в которых символы представляются более длинными кодами. Рассмотрим пример работы с std::strin.
     #+begin_src C++
       const char* vulgarHyphen = " - ";
       size_t length = strlen(vulgarHyphen);
       std::string properDash = "\u00A0\uu2013 ";
       std::string input;
       std::cin >> input;
       do
           {
               auto index = input.find(vulgarHyphen);
               if(index == std::string::npos)
                   break;
               input.replace(index, length, properDash);
           }while(true);
       puts(input,c_str());
     #+end_src
     Программа выполняет замену дефисов, обрамленных пробелами, на длинные тире с неразрывным пробелом. В строке 3 демонстрируется создание объекта-строки по заданной строке С. На строке 7 применяется метод find() для поиска подстроки; он возвращает std::string::npos, если подстрока не найдена. Метод replace(), вызываемый на строке 10, в строке input заменяет length символов, начиная с позиции index, на строке properDash. В строке 12 производится печать функцией puts(); для получения из std::string строки C используется метод c_str(). Класс std::string является также полноценным контейнером, поэтому имеет итераторы, и может быть обработан алгоритмами STL.
**** Особенности чтения данных в бинарном и текстовом виде. Преобразования при чтении.
     Двоичные файлы имеют следующие преимущества по сравнению с текстовыми: возможность прямого доступа к компонентам файла и возможность записи/чтения за одно обращение к файлу нескольких (не одного) компонентов файла. Длина любого компонента двоичного файла строго постоянна, что дает возможность организовать прямой доступ к каждому компоненту.
     Текстовыми называются файлы, состоящие из любых символов. Они организуются по строкам, каждая из которых заканчивается символом «конца строки». Конец самого файла обозначается символом «конца файла». При записи информации в текстовый файл, просмотреть который можно с помощью любого текстового редактора, все данные преобразуются к символьному типу и хранятся в символьном виде.
     В бинарных файлах информация считывается и записывается в виде блоков определенного размера, в которых могут храниться данные любого вида и структуры.
     Файловая система делает организованную структуру на накопителе информации. Все записанные данные на нем хранятся в своих определенных местах, под определенными именами и с присвоенными атрибутами. Если бы ФС не было, то файлы хранились бы на носителе просто в одном большом массиве данных и определить, где начало какого файла и его конец, было бы невозможно. Система бы просто не знала, как вытащить необходимый файл. Файловая система не обязательно связана с физическим носителем информации. Существуют и виртуальные файловые системы, а также сетевые файловые системы.
     Задачи файловой системы:
     — именование файлов;
     — программный интерфейс работы с файлами для программ;
     — отображение логической модели файловой системы на физическую организацию хранилища данных;
     — организация устойчивости файловой системы к сбоям питания, ошибкам аппаратных и программных средств;
     — содержание параметров файла, необходимых для правильного его взаимодействия с другими объектами системы;
     — защита файлов от несанкционированного доступа другого пользователя.
*** Файловая система (Работа с файлами)
**** Понятие “файловая система”. Файловая система NTFS, её возможност
     Файловая система – способ организации данных в виде файлов на устройствах внешней памяти.
     В настоящее время NTFS рассматривается в качестве предпочтительной файловой системы как для серверных, так и для клиентских версий Windows. В NTFS используются 64-разрядные идентификаторы кластеров, поэтому теоретически том NTFS может содержать 2^64 кластеров
     Перечислим некоторые возможности NTFS
     восстанавливаемость – способность файловой системы возвращаться к работоспособному состоянию после возникновения сбоя
     безопасность – защищенность файлов от несанкционированного доступа
     шифрование – преобразование файла в зашифрованный код, который невозможно прочесть без ключа.
     поддержка RAID (Redundant Array of Inexpensive (Independent) Disks – массив недорогих (независимых) дисков с избыточностью) – возможность использования для хранения информации нескольких дисков; данные с одного диска автоматически копируются на другие, обеспечивая тем самым повышенную надежность;
     дисковые квоты для пользователей – возможность выделения для каждого пользователя определенного пространства на диске (квоты);
**** Способы получения информации о файлах и папках в операционной системе Windows (WinAPI или другие библиотеки). Принцип работы.
     Для работы с файлами необходимо подключить заголовочный файл <fstream>. В <fstream> определены несколько классов и подключены заголовочные файлы <ifstream> — файловый ввод и <ofstream> — файловый вывод.
     #+begin_src C++
       fout.open("Название.txt"); // открытие файла 
       fout << "Какой-нибудь текст"; // запись строки в файл 
       fout.close(); // закрытие файла 
       fin.getline(ch, 50); // считать строку из файла (ch – массив char’ов) 
       //Вычислить размер файла можно с помощью команд: 
       fin.seekg(0, ios::end); // перемещает курсор в конец файла 
       size = fin.tellg(); // определяет положение курсора (=>получаем размер файла в байт)
     #+end_src
**** Опишите рекурсивный алгоритм (можно словесно) расчета размера папки.
     #+begin_src C++
       static double sizeOfFolder(string folder, ref double catalogSize)
       {
           try
               {
                   //В переменную catalogSize будем записывать размеры всех файлов, с каждым
                   //новым файлом перезаписывая данную переменную
                   DirectoryInfo di = new DirectoryInfo(folder);
                   DirectoryInfo[] diA = di.GetDirectories();
                   FileInfo[] fi = di.GetFiles();
                   //В цикле пробегаемся по всем файлам директории di и складываем их размеры
                   foreach (FileInfo f in fi)
                       {
                           //Записываем размер файла в байтах
                           catalogSize = catalogSize + f.Length;
                       }
                   //В цикле пробегаемся по всем вложенным директориям директории di 
                   foreach (DirectoryInfo df in diA)
                       {
                           //рекурсивно вызываем наш метод
                           sizeOfFolder(df.FullName, ref catalogSize);
                       }
                   //1ГБ = 1024 Байта * 1024 КБайта * 1024 МБайта
                   //return Math.Round((double)(catalogSize / 1024 / 1024 / 1024), 1);
                   return Math.Round((double)(catalogSize / 1024 / 1024 / 1024), 1);
               }
           //Начинаем перехватывать ошибки
           //DirectoryNotFoundException - директория не найдена
           catch (DirectoryNotFoundException ex)
               {
                   Console.WriteLine("Директория не найдена. Ошибка: " + ex.Message);
                   return 0;
               }
           //UnauthorizedAccessException - отсутствует доступ к файлу или папке
           catch (UnauthorizedAccessException ex)
               {
                   Console.WriteLine("Отсутствует доступ. Ошибка: " + ex.Message);
                   return 0;
               }
           //Во всех остальных случаях
           catch (Exception ex)
               {
                   Console.WriteLine("Произошла ошибка. Обратитесь к администратору. Ошибка: " + ex.Message);
                   return 0;
               }
       }
     #+end_src
**** Указатели. Определение, операции над указателями, разыменование указателей, оператор получения адреса. Примеры использования указателей. "Нулевой" указатель. Утечка памяти.
     Указатель — это переменная, значением которой является адрес ячейки памяти. 1) Оператор адреса & позволяет узнать, какой адрес памяти присвоен определенной переменной
     #+begin_src C++
       std::cout << &a << '\n'; // выводим адрес памяти переменной a.
     #+end_src
     2) Оператор разыменования * позволяет получить значение по указанному адресу.
     #+begin_src C++
       std::cout << *&a << '\n'; // выводим значение ячейки памяти переменной a.
     #+end_src
     Операции над указателями:
     1. Присваивание значений указателю.
     Поскольку указатели содержат только адреса, то при присваивании указателю значения — это значение должно быть адресом.
     #+begin_src C++
       int value = 5;
       int *ptr = &value; // инициализируем ptr адресом значения переменной
     #+end_src
     2. Разыменование указателей.
     Указатель можно разыменовать, чтобы получить значение, на которое он указывает.
     #+begin_src C++
       std::cout << *ptr << std::endl; // разыменовываем ptr (получаем значение на которое указывает ptr)
     #+end_src
     Указатели полезны в следующих случаях: 1. Массивы реализованы с помощью указателей.
     2. Они являются единственным способом динамического выделения памяти в C++.
     3. Они могут использоваться для передачи большого количества данных в функцию без копирования этих данных.
     4. Они могут использоваться для передачи одной функции в качестве параметра другой функции.
     5. Они используются для достижения полиморфизма при работе с наследованием. 6. Они могут использоваться для представления одной структуры/класса в другой структуре/классе, формируя, таким образом, целые цепочки.
     Нулевое значение (или «значение null») — это специальное значение, которое означает, что указатель ни на что не указывает. Указатель, содержащий значение null, называется нулевым указателем:
     #+begin_src C++
       int *ptr = nullptr;
     #+end_src
     Утечка памяти. Утечка памяти происходит, когда ваша программа теряет адрес некоторой динамически выделенной части памяти (например, переменной или массива), прежде чем вернуть её обратно в операционную систему. Когда это происходит, то программа уже не может удалить эту динамически выделенную память, поскольку больше не знает, где выделенная память находится.
     Когда происходит: 1) указатель выходит из области видимости;
     2) если указателю, хранящему адрес динамически выделенной памяти, присвоить другое значение;
     #+begin_src C++
       int value = 7;
       int *ptr = new int; // выделяем память
       ptr = &value; // старый адрес утерян - произойдет утечка памяти
     #+end_src
     3) может произойти и через двойное выделение памяти
     #+begin_src C++
       int *ptr = new int;
       ptr = new int; // старый адрес утерян - произойдет утечка памяти
     #+end_src
**** Функции. Определение понятия, преимущества использования функций. Объявление и определение функции. Параметры функции. Процедура. Области видимости переменных. Передача параметров в функцию по значению, по указателю (ссылке). Примеры. 
     Фу́нкция— элемент структурного программирования, позволяющий группировать и обобщать программный код, который может позднее использоваться произвольное число раз.
     Использование функций в программах дает следующие преимущества:
     · компактная организация программы путем удобного вызова программного кода по его имени, который в программе может встречаться несколько раз (повторяться);
     · экономия памяти, размера исходного и исполнительного кода и т.д.;
     · уменьшение риска возникновения ошибок для больших наборов кодов;
     · повышение читабельности программного кода.
     Определение функции.
     Определение функции состоит из двух частей: заголовка и тела. Заголовок функции дает определение имени функции, типа результата, формальных параметров. Тело функции состоит из оператора (блока), описывающего выполняемые функцией действия. Общий вид определения функции таков:
     #+begin_src C++
       int h(/*...*/)//тип имя_функции(параметры)
       {
           //инструкции
       }
     #+end_src
     Первая строка представляет заголовок функции. Вначале указывается возвращаемый тип функции. Если функция не возвращает никакого значения, то используется тип void.
     Затем идет имя функции, которое представляет произвольный идентификатор. К именованию функции применяются те же правила, что и к именованию переменных.
     После имени функции в скобках идет перечисление параметров. Функция может не иметь параметров, в этом случае указываются пустые скобки.
     После заголовка функции в фигурных скобках идет тело функции, которое содержит выполняемые инструкции.
     Для возвращения результата функция применяет оператор return. Если функция имеет в качестве возвращаемого типа любой тип, кроме void, то она должна обязательно с помощью оператора return возвращать какое-либо значение.
     Для выполнения функции ее необходимо вызвать. Вызов функции осуществляется в форме: имя_функции(аргументы);
     Объявление функции
     При использовании функций стоит учитывать, что компилятор должен знать о функции до ее вызова. Поэтому вызов функции должен происходить после ее определения. объявление выглядит следующим образом: тип имя_функции(параметры);
     Объявление — это Инстру́кция , которая сообщает компилятору о существовании идентификатора и о его типе. Вот примеры объявлений:
     Параметр функции — это принятый функцией аргумент, значение, переданное из вызывающего кода. Различают: фактический параметр — аргумент, передаваемый в функцию при ее вызове; формальный параметр — аргумент, указываемый при объявлении или определении функции
     Процедура представляет собой последовательность операторов, которая имеет имя, список параметров и может быть вызвана из различных частей программы. Функции, в отличие от процедур, в результате своего выполнения возвращают значение, которое может быть использовано в выражении.
     Область видимости переменной определяет, кто может видеть и использовать переменную во время её существования. И параметры функции, и переменные, которые объявлены внутри функции, имеют локальную область видимости. Другими словами, эти параметры и переменные используются только внутри функции, в которой они объявлены. Локальные переменные создаются в точке объявления и уничтожаются, когда выходят из области видимости.
     Передача параметров в функцию по значению - Данный метод копирует содержимое аргумента в формальный параметр подпрограммы. Изменения, сделанные в параметре, не влияют на значение переменной, используемой при вызове.
     Пример
     #+begin_src C++
       #include <iostream>
       void square(int, int);
       int main()
       {
           int a = 4;
           int b = 5;
           std::cout << "Before square: a = " << a << "\tb=" << b << std::endl;
           square(a, b);
           std::cout << "After square: a = " << a << "\tb=" << b << std::endl;
           return 0;
       }
       void square(int a, int b)
       {
           a = a * a;
           b = b * b;
           std::cout << "In square: a = " << a << "\tb=" << b << std::endl;
       }
     #+end_src
     Передача параметров в функцию по указателю (ссылке) - В данном методе копируется адрес аргумента. В подпрограмме адрес используется для доступа к настоящему аргументу, используемому при вызове. То есть, изменения, сделанные в параметре, влияют на содержимое переменной, используемой при вызове.
     Пример
     #+begin_src C++
       #include <iostream>
       void square(int&, int&);
       int main()
       {
           int a = 4;
           int b = 5;
           std::cout << "Before square: a = " << a << "\tb=" << b << std::endl;
           square(a, b);
           std::cout << "After square: a = " << a << "\tb=" << b << std::endl;
           return 0;
       }
       void square(int &a, int &b)
       {
           a = a * a;
           b = b * b;
           std::cout << "In square: a = " << a << "\tb=" << b << std::endl;
       }
     #+end_src
*** Связи
**** Язык UML. Диаграммы классов. Пример изображения класса на диаграмме с пояснениями.
     UML – унифицированный язык моделирования – это система обозначений, которую можно применять для объектно-ориентированного анализа и проектирования. Его можно использовать для визуализации, спецификации, конструирования и документирования программных систем.
     Диаграммы классов показывают набор классов, интерфейсов, а также их связи. Диаграммы этого вида чаще всего используются для моделирования объектно-ориентированных систем. Они предназначены для статического представления системы. Большинство элементов UML имеют уникальную и прямую графическую нотацию, которая дает визуальное представление наиболее важных аспектов элемента.
     Сущности
     Диаграммы классов оперируют тремя видами сущностей UML:
     · Структурные.
     · Поведенческие.
     · Аннотирующие.
     Пример диаграммы классов.
     На рис. приведен фрагмент диаграммы классов, который включает в себя описание класса «Сотрудник» и двух наследуемых классов: «Кассир» и «Мерчендайзер». В качестве кассира и мерчендайзера рассматриваются не конкретные люди, а роль, которая соотносится с одним или несколькими сотрудниками предприятия.

     [[https://studme.org/htm/img/15/2316/123.png]]

     Диаграмма классов является одной из наиболее важных в объектно-ориентированном анализе и проектировании. Диаграмма классов позволяет создать своеобразный «мост» между архитекторами И С, для которых наибольшее значение имеет предметная область, и программистами, использующими классы для понимания поведения объектов.
**** Дать определение терминам связь и отношение. Отношение наследования. Пример класса ассоциации.
     Связь — это физическое или концептуальное соединение между объектами. Например, Саша учится в СФУ. Чаще всего связь соединяет ровно два объекта. Отношение — это набор связей, которые обладают общей структурой и общей семантикой. Например, студент может учиться в каком-либо учебном заведении. Отношение описывает множество потенциальных однотипных связей точно так же, как класс описывает множество потенциальных объектов. Связи - экземпляры отношения, соединяющие объекты тех классов, между которыми отношение установлено. Отношение обобщения (наследования, ≪is a≫) между классами показывает, что подкласс(производный класс) разделяет атрибуты и операции, определенные в одном или нескольких суперклассах (базовых классах). На диаграмме классов отношение наследования показывают линией со стрелкой в виде не закрашенного треугольника, которая указывает на базовый класс. Допускается объединять несколько стрелок в одну, с тем чтобы разгрузить диаграмму. Пример: в системе обслуживания читателей имеются две ключевые абстракции — Книга и Библиотека. Класс Книга играет роль элемента, хранимого в библиотеке. Класс Библиотека играет роль хранилища для книг. Или: Человек работает в компании
**** Типы отношений, дать короткую характеристику каждому из них, их графическое обозначение.
     Ассоциация Самым распространённым типом отношений является ассоциация, которая отражает значимые и полезные связи объектов. По своей природе ассоциация двусторонняя, имеет два конца и может быть прослежена как в одном, так и в обоих направлениях. Ассоциация может иметь имя, используемое для описания природы связи. Поэтому значение имени не должно быть двусмысленным. Используя стрелочку в форме треугольника, вы можете указать направление, в котором следует читать это имя Ассоциация представляет структурную связь между объектами. Во многих ситуациях моделирования важно знать, сколько объектов может быть соединено одним экземпляром ассоциации. Этот параметр называется множественностью роли ассоциации.

     Множественность представляет диапазон целых чисел, указывающий возможное количество связанных объектов. Он записывается в виде выражения с минимальным и максимальным значением, которые могут быть равны; для их разделения используются две точки. Устанавливая множественность дальнего конца ассоциации, вы указываете, сколько объектов может существовать на дальнем конце ассоциации для каждого объекта класса, находящегося на ближнем ее конце. Количество объектов должно находиться в пределах заданного диапазона.

     Наследование. Отношение обобщения (наследования, ≪is a≫) между классами показывает, что подкласс (производный класс) разделяет атрибуты и операции, определенные в одномили нескольких суперклассах (базовых классах). На диаграмме классов отношение наследования показывают линией со стрелкой в виде не закрашенного треугольника, которая указывает на базовый класс. Допускается объединять несколько стрелок в одну, с тем чтобы разгрузить диаграмму.

     Агрегация. Отношение агрегации показывает, что один класс содержит в качестве составной части объекты другого класса. Иными словами, это отношение целое–часть, или отношение ≪has a≫, между двумя классами. На диаграмме такая связь обозначается линией со стрелкой в виде не закрашенного ромба, которая указывает на целое.

     Строгая агрегация имеет специальное название — композиция. Она означает, что компонент не может исчезнуть, пока объект целое существует. Проще всего композицию реализовать включением объектов-компонентов по значению. В то же время возможна реализация и включением по ссылке, но тогда времена жизни компонентов и объекта целое должны совпадать.

     Зависимость. Отношение зависимости (использования) показывает, что один класс пользуется услугами другого класса.
**** Понятие массива. Статические массивы. Определение, в каких случаях используются, отличие от динамических массивов. Примеры.
     Массив — это непрерывный участок памяти, содержащий последовательность объектов одинакового типа, обозначаемый одним именем. Массив характеризуется следующими основными понятиями: Элемент массива (значение элемента массива) – значение, хранящееся в определенной ячейке памяти, расположенной в пределах массива, а также адрес этой ячейки памяти.

     Статические массивы как и другие статические типы данных это объекты размер которых известен на этапе компиляции. То есть до выполнения кода, когда программа запрашивает память у операционной системы она может выделить память в области данных, - по младшим адресам сегмента программы.

     Статистические массивы используются так как:

     1. Статические массивы могут быть оптимизированы компилятором, так как их размер известен во время компиляции.

     2. Динамическое выделение памяти используется только в том случае, если программе заранее неизвестно, какой размер памяти нужно отвести под данные.

     3. Динамические массивы используют динамическое выделение памяти, что может быть дорогостоящим.

     Приведем простую программу, которая вводит, а затем выводит на консоль элементы массива из трех элементов. (Статический)
     #+begin_src C++
       #include <stdio.h>
       int main()
       {
           int a[3];
           printf("Input 3 integers: ");
           for(int i=0; i<3; i++)
               scanf("%d", &a[i]);
           printf("The array:\n");
           for(int i=0; i<3; i++)
               printf("a[%d] = %d ", i, a[i]);
           printf("\n");
           return 0;
       }
     #+end_src
     Программа, которая динамически создает одномерный целочисленный массив. (Динамический)
     #+begin_src C++
       #include <stdio.h>
       #include <stdlib.h>

       int main()
       {

           int  *a, n;  // указатель на массив, размерность массива

           printf("Input a size of an array: ");
           scanf("%d", &n);

           // выделяем память под массив
           a = (int*)malloc(n * sizeof(int));

           // если ошибка, то выходим из программы
           if (!a)
               {
                   printf("Error: there is no memory.\n");
                   return 0;
               }

           // вводим элементы массива
           printf("Input elements of the array: ");
           for (int i = 0; i < n; ++i)
               scanf("%d", &a[i]);

           // можно ввести элементы массива и так
           printf("Input elements of the array: ");
           for (i = 0; i < n; ++i)
               scanf("%d", a + i);

           // что-то делаем с массивом

           printf("You input the array: ");
           for (i = 0; i < n; ++i)
               printf("%d ", a[i]);
           printf("\n");

           // освобождаем выделенную память
           free(a);
           return 1;
       }
     #+end_src
**** Динамические массивы. Определение, в каких случаях используются, отличие от статических массивов. Выделение и освобождение памяти (оператор new), объяснить механизмы работы. Масштабирование (алгоритм). 
     Выделение и освобождение памяти (оператор new), объяснить механизмы работы. Масштабирование (алгоритм): Массив, размер которого может изменяться во время исполнения программы. Динамические массивы используются для обработки наборов однородных данных, размер которых не

     известен точно на момент написания программы, но которые потенциально могут разместиться в доступной памяти. Отличия от статистических массивов:

     a) Размер массива определяется во время выполнения программы

     b) Память под массив выделяется вручную программистом (оператор new).

     c) Требуется очистка (удаление) памяти вручную (оператор delete).

     Оператор new выделяет память для объекта или массива объектов типа-Name из свободного хранилища и возвращает подходящим образом типизированный ненулевой указатель на объект. Маштабирование - ???
*** Визуальное программирование
**** Приведите примеры некоторых технологий/библиотек/фреймворков для создания оконных приложений для операционной системы Windows на языке C++. Приведите некоторые особенности.
     Qt — очень мощный набор инструментов для создания кроссплатформенных приложений на языке С++ и Python. Qt уже достаточно старый Фреймворк, но он продолжает активно развиваться и на нем написаны такие программы как: 2ГИС для Android, Kaspersky Internet Security, Virtual Box, Skype, VLC Media Player, Opera и другие.

     Плюсы

     1) Визуальный редактор интерфейса

     2) Огромное количество модулей в составе фреймворка

     3) Поддержка большого количества языков программирования -> хорошая нативность при грамотном коде

     4) Низкий порог вхожденияМинусы

     1) Большой вес приложения

     2) Высокая стоимость коммерческой лицензии

     2. GTK на ряду с Qt является одной из самых популярных библиотек для кроссплатформенной разработки элементов интерфейса для X Window Systems. С использованием этой библиотеки написаны. программы, например: Chromium, FireFox, MonoDevelop, Gimp и другие. GTK написан на языке C, но существуют обертки для многих языков программирование (C, C++, Python, Java и другие).

     Плюсы

     1) Поддержка большого количества языков

     2) Большое и активное сообщество

     3) Много популярных проектов и примеров

     4) Визуальный редактор
**** Приведите примеры некоторых элементов управления (Qt/WinApi/MFC) и принципы работы с ними. (Не менее пяти)
     1. Кнопка(Button)

     Кнопка — маленькое дочернее окно, по которой пользователь может щелкать мышью, чтобы включить или выключить ее. Кнопки управления могут использоваться самостоятельно или в группах. Кнопки управления обычно изменяют свой вид, когда пользователь щелкает мышью по ним.

     (При нажатии кнопки операционная система генерирует сообщение WM_COMMAND с параметром lParam, соответствующим дескриптору кнопки.)

     2. Поле редактирования

     Поле редактирования — дочернее окно, внутри которого пользователь может напечатать с клавиатуры текст. Пользователь выбирает орган управления и дает ему фокус клавиатуры, щелкая по нему мышью или перемещая в него, каретку путем нажатия клавиши ТАБУЛЯЦИИ (TAB). Пользователь может вводить текст, когда окно редактирования текста отображает мигающую каретку.

     3. Статический текст

     Статический текст — текстовое поле, окно или прямоугольник, используемый для надписей, не подлежащих редактированию. Для установки статического текста используется та же функция SetWindowText.

     4. Список (ListBox)

     С помощью списка "listbox" можем создавать одноколоночные и многоколоночные списки, имеющие вертикальную и горизонтальную полосу просмотра. Родительское окно может само рисовать элементы списка, аналогично тому, как оно рисует кнопки.

     5. Полосы просмотра (Scrollbar)

     Полоса просмотра представляет собой орган управления, созданный на базе предопределенного класса "scrollbar". Горизонтальная и вертикальная полоса просмотра посылают в функцию родительского окна сообщения WM_HSCROLL и WM_VSCROLL. Параметр WParam этих сообщений несет в себе информацию о действии, которое вы выполнили над полосой просмотра.

     Полоса просмотра состоит из нескольких объектов, имеющих различное назначение.
**** Шаблоны проектирования. Шаблон MVC, его преимущества.
     Шаблон проектирования - повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста (шаблон не является законченным образцом, который может быть прямо преобразован в код; это лишь пример решения задачи, который можно использовать в различных ситуациях.)

     MVC — подход к проектированию приложения, который предполагает выделение кода в блоки модель, представление и контроллер Преимущества: Единая глобальная архитектура приложения, т.е. возможность легко ориентироваться в программных блоках.

     Механизм визуализации теперь сконцентрирован в одном программном блоке, упростились механизмы опционального вывода графических элементов.
**** Циклы в С++(основные понятия). Разновидности циклов, для чего используется каждый из них. Примеры. Блочный оператор. Оператор множественного выбора.
     Цикл for применяется если тело цикла необходимо выполнить определенное число раз. Цикл выполняется в следующем порядке:

     1. инициализация счетчика;

     2. проверка условия — если результат развен false — цикл завершается;

     3. тело цикла;

     4. изменение счетчика;

     5. проверка условия — если результат развен false — цикл завершается;

     6. тело цикла;

     7. изменение счетчика;

     8. … (и так далее пока при проверке условия не будет получен false).

     Цикл while очень похож на for, но является наиболее общим — его стоит применять только если заранее не известно сколько раз нужно выполнить тело цикла. Оператор break немедленно завершает выполнение цикла и переходит к первой инструкции, записанной после цикла. Оператор continue — немедленно переходит к новой итерации цикла. ОПЕРАТОР МНОЖЕСТВЕННОГО ВЫБОРА Оператор switch может быть заменен оператором if. Однако, в некоторых случаях использование оператора switch может быть более эффективным, чем использование оператора if. Оператор switch работает следующим образом. Сначала вычисляется значение выражение. Потом это значение последовательно сравнивается с константами из заданного списка. Как только найдено совпадение для одного из условий сравнения (ветвь case), выполняется последовательность инструкций, которые связаны с этим сравнением. Если не найдено ни одного совпадения, то выполняются операторы, которые следуют после ключевого слова default. Блок — это последовательность операторов, заключенных в фигурные скобки и

     рассматриваются как одна программная единица. Операторы, составляющие блок, логически связаны друг с другом. Иногда блок называют составным оператором. Блок всегда начинается открывающейся фигурной скобкой { и заканчивается закрывающейся }. Чаще всего блок используется как составная часть какого-либо оператора, выполняющего действие над группой операторов, например, if или for. Однако блок можно поставить в любом месте, где может находиться оператор
**** Многомерные массивы, ассемблерный стиль, Си-стиль (статически-создаваемый). Доступ к элементам многомерного массива. Выделение и освобождение памяти под двумерный динамический Си-массив. Схематически изобразить хранение данных двумерного си-массива.
 
** Практика
*** DONE Блок задач первого семестра
    CLOSED: [2021-06-15 Tue 20:07]
**** DONE 1)
     CLOSED: [2021-06-15 Tue 16:33]
     Оформить в виде функции фрагмент программы, меняющий местами максимальный и
     минимальный элементы целочисленного массива. Массив передать в функцию через
     параметры функции.
     #+begin_src C++ :includes <iostream> 
       int* h(int* mas, int size)
       {
           int max = 0,
               min = 9999;
           bool max_end = false,
               min_end = false;
           for(int i=0; i<size; i++)
               {
                   if(mas[i] > max)
                       {
                           max = mas[i];
                       }
                   if(mas[i] < min)
                       {
                           min = mas[i];
                       }
               }
           for(int i=0; i<size; i++)
               {
                   if(mas[i] == max && !max_end)
                       {
                           mas[i] = min;
                           max_end = true;
                           continue;
                       }
                   if(mas[i] == min && !min_end)
                       {
                           mas[i] = max;
                           min_end = true;
                           continue;
                       }
               } 
           return mas;
       }

       int main()
       {
           int *mas = NULL,
               size = 5;
           mas = (int*)calloc(size, sizeof(int));
           for(int i=0; i<size; i++)
               {
                   mas[i] = i;
               }
           mas[1] = 4;
           h(mas, size);
           return 0;

       }
     #+end_src

     #+RESULTS:
**** DONE 2)
     CLOSED: [2021-06-15 Tue 16:33]
     Написать фрагмент программы, выводящий на экран элементы массива целых чисел,
     превышающих среднее арифметическое всех элементов. Поиск среднего арифметического
     оформить в виде отдельной функции.
     #+begin_src C++ :includes <iostream> 
       int h(int* mas, int size)
       {
           int sa = 0;
           for(int i=0; i<size; i++)
               {
                   sa += mas[i];
               }
           sa /= size;
           return sa;
       }

       int main()
       {
           int *mas = NULL,
               size = 5,
               sa = 0;
           mas = (int*)calloc(size, sizeof(int));
           for(int i=0; i<size; i++)
               {
                   mas[i] = i;
               }
           sa = h(mas, size);
           for(int i=0; i<size; i++)
               {
                   if(mas[i] > sa)
                       {
                           printf("%d ", mas[i]);   
                       }
               }
           return 0;

       }
     #+end_src

     #+RESULTS:
     : 3 4

**** DONE 3)
     CLOSED: [2021-06-15 Tue 16:33]
     Написать фрагмент программы, удаляющий i-й элемент из массива целых чисел
     размера N, i <= N. Фрагмент оформить в виде функции, массив передать в функцию через
     параметры.
     #+begin_src C++ :includes <iostream> 
       int* h(int* mas, int &size, int f)
       {
           int *temp = NULL,
               k = 0;
           temp = (int*)calloc(size-1, sizeof(int));
           for(int i=0; i<size; i++)
               {
                   if(i != f)
                       {
                           temp[k] = mas[i];
                           k++;
                       }
               }
           size -= 1;
           return temp;
       }

       int main()
       {
           int *mas = NULL,
               size = 5;
           mas = (int*)calloc(size, sizeof(int));
           for(int i=0; i<size; i++)
               {
                   mas[i] = i;
               }
           mas = h(mas, size, 1);
           for(int i=0; i<size; i++)
               printf("%d ", mas[i]);
           return 0;

       }
     #+end_src

     #+RESULTS:
     : 0 2 3 4

**** DONE 4)
     CLOSED: [2021-06-15 Tue 16:33]
     Написать фрагмент программы, находящий в одномерном массиве, состоящем из n
     вещественных элементов, среднее значение всех элементов и заменяющий им
     наименьший элемент.
     #+begin_src C++ :includes <iostream> 
       int h(int* mas, int size)
       {
           int sa = 0;
           for(int i=0; i<size; i++)
               {
                   sa += mas[i];
               }
           sa /= size;
           return sa;
       }

       int main()
       {
           int *mas = NULL,
               size = 5,
               sa = 0,
               min = 9999;
           mas = (int*)calloc(size, sizeof(int));
           for(int i=0; i<size; i++)
               {
                   mas[i] = i;
               }
           sa = h(mas, size);
           for(int i=0; i<size; i++)
               {
                   if(mas[i] < min)
                       {
                           min = mas[i];
                       }
               }
           for(int i=0; i<size; i++)
               {
                   if(mas[i] == min)
                       {
                           mas[i] = sa;
                           break;
                       }
               }

           for(int i=0; i<size; i++)
               printf("%d ", mas[i]);
           return 0;

       }
     #+end_src

     #+RESULTS:
     : 2 1 2 3 4

**** DONE 5)
     CLOSED: [2021-06-15 Tue 16:33]
     Дана строка (Си-строка), содержащая текст. Написать фрагмент программы,
     выводящий на экран встречающиеся в строке цифры.
     #+begin_src C++ :includes <iostream>, <cstring>
       int main()
       {
           char str[] = "AES512 is good";

           char num[] = "0123456789";
           printf("%s\n", str);
           for(int i=0; i<strlen(str); i++)
               {
                   for(int j=0; j<10; j++)
                       {
                           if(str[i] == num[j])
                               std::cout << str[i] << " ";
                       }
               }
           std::cout << std::endl;
           return 0;
       }
     #+end_src

     #+RESULTS:
     | AES512 | is | good |
     |      5 |  1 |    2 |

**** DONE 6)
     CLOSED: [2021-06-15 Tue 19:16]
     Написать фрагмент программы для транспонирования прямоугольной матрицы.
     (Двумерный динамический массив)
 #+begin_src C++ :includes <iostream>
   #include <iostream>

   using namespace std;

   int main()
   {
       int size_h = 3,
           size_w = 2;
       int Matrix[size_h][size_w] = {
           { 1, 2},
           { 2, 4},
           { 3, 6}
       };

       for(int i=0; i<size_h; i++)
           {
               for(int j=0; j<size_w; j++)
                   {
                       cout << Matrix[i][j] << " ";
                   }
               cout << "\n";
           }

       int **T_Matrix = nullptr;
       T_Matrix = new int*[size_w];
       for(int i=0; i<size_h; i++)
           {
               T_Matrix[i] = new int[size_w];
           }
       for(int i=0; i<size_w; i++)
           {
               for(int j=0; j<size_h; j++)
                   {
                       T_Matrix[i][j] = Matrix[j][i];
                   }  
           }
       for(int i=0; i<size_w; i++)
           {
               for(int j=0; j<size_h; j++)
                   {
                       cout << T_Matrix[i][j] << " ";
                   }
               cout << "\n";
           }

   }
 #+end_src

 #+RESULTS:
 | 1 | 2 |   |
 | 2 | 4 |   |
 | 3 | 6 |   |
 | 1 | 2 | 3 |
 | 2 | 4 | 6 |

**** DONE 7)
     CLOSED: [2021-06-15 Tue 19:26]
     Написать фрагмент программы, определяющий, является ли произвольная
     прямоугольная матрица симметричной относительно главной диагонали. (Двумерный
     динамический массив)
 #+begin_src C++ :includes <iostream>
   #include <iostream>

   using namespace std;

   int main()
   {
       int size_h = 3,
           size_w = 3;
       int Matrix[size_h][size_w] = {
           { 1, 1, 3},
           { 2, 4, 1},
           { 3, 1, 2}
       };

       for(int i=0; i<size_h; i++)
           {
               for(int j=0; j<size_w; j++)
                   {
                       cout << Matrix[i][j] << " ";
                   }
               cout << "\n";
           }
       if(size_h != size_w)
           {
               printf("no\n");
               return 0;
           }
    
       int **T_Matrix = nullptr;
       T_Matrix = new int*[size_w];
       for(int i=0; i<size_h; i++)
           {
               T_Matrix[i] = new int[size_w];
           }
       for(int i=0; i<size_w; i++)
           {
               for(int j=0; j<size_h; j++)
                   {
                       T_Matrix[i][j] = Matrix[j][i];
                   }  
           }
       cout << "\n";
       for(int i=0; i<size_w; i++)
           {
               for(int j=0; j<size_h; j++)
                   {
                       cout << T_Matrix[i][j] << " ";
                   }
               cout << "\n";
           }
       for(int i=0; i<size_w; i++)
           {
               for(int j=0; j<size_h; j++)
                   {
                       if(Matrix[i][j] != T_Matrix[i][j])
                           {
                               printf("no\n");
                               return 0;
                           }
                   }
           }
       printf("yes\n");
       return 0;
   }
 #+end_src

 #+RESULTS:
 |  1 | 1 | 3 |
 |  2 | 4 | 1 |
 |  3 | 1 | 2 |
 |    |   |   |
 |  1 | 2 | 3 |
 |  1 | 4 | 1 |
 |  3 | 1 | 2 |
 | no |   |   |

**** DONE 8)
     CLOSED: [2021-06-15 Tue 19:36]
     Написать фрагмент программы, заменяющий в произвольной квадратной матрице
     строку с минимальным элементом матрицы нулями. (Двумерный динамический массив)
 #+begin_src C++ :includes <iostream>
   int size = 3;
   int min = 9999, min_str = 0;
   int Matrix[size][size] =
       {
           {1, 2, 3},
           {1, -1, 3},
           {1, 0, 3}
       };

   for(int i=0; i<size; i++)
       {
           for(int j=0; j<size; j++)
               {
                   if(min > Matrix[i][j])
                       {
                           min = Matrix[i][j];
                           min_str = i;
                       }
               }
       }

   for(int i=0; i<size; i++)
       {
           Matrix[min_str][i] = 0;
       }

   for(int i=0; i<size; i++)
       {
           for(int j=0; j<size; j++)
               {
                   std::cout << Matrix[i][j] << " ";
               }
           std::cout << "\n";
       }

 #+end_src

 #+RESULTS:
 | 1 | 2 | 3 |
 | 0 | 0 | 0 |
 | 1 | 0 | 3 |

**** DONE 9)
     CLOSED: [2021-06-15 Tue 19:54]
     Дана целочисленная прямоугольная матрица. Написать фрагмент программы,
     определяющей количество столбцов, содержащих хотя бы один нулевой элемент.
     Оформить в виде функции. (Двумерный динамический массив)
 #+begin_src C++ :includes <iostream>
   int col(int **mas, int size_h, int size_w)
   {
       int many = 0;
       for(int i=0; i<size_h; i++)
           {
               for(int j=0; j<size_w; j++)
                   {
                       if(mas[j][i] == 0)
                           {
                               many++;
                               break;
                           }
                   }
           }
       return many;
   }

   int main()
   {
       int size_h = 3;
       int size_w = 3;
       int Matrix[size_h][size_w] =
           {
               {1, 2, 3},
               {1, 1, 3},
               {0, 0, 3}
           };
       int** mas = new int*[size_w];
       for(int i = 0; i<size_w; i++)
       {
           mas[i] = &Matrix[i][0];
       }

       std::cout << col(mas, size_h, size_w) << "\n";
       return 0;
   }
 #+end_src

 #+RESULTS:
 : 2

**** DONE 10)
     CLOSED: [2021-06-15 Tue 20:07]
     Дана целочисленная прямоугольная матрица. Написать фрагмент программы,
     определяющей количество строк, содержащих хотя бы один нулевой элемент.
     (Двумерный динамический массив)
 #+begin_src C++ :includes <iostream>
   int col(int **mas, int size_h, int size_w)
   {
       int many = 0;
       for(int i=0; i<size_h; i++)
           {
               for(int j=0; j<size_w; j++)
                   {
                       if(mas[i][j] == 0)
                           {
                               many++;
                               break;
                           }
                   }
           }
       return many;
   }

   int main()
   {
       int size_h = 3;
       int size_w = 3;
       int Matrix[size_h][size_w] =
           {
               {1, 2, 0},
               {1, 1, 3},
               {2, 0, 3}
           };
       int** mas = new int*[size_w];
       for(int i = 0; i<size_w; i++)
       {
           mas[i] = &Matrix[i][0];
       }

       std::cout << col(mas, size_h, size_w) << "\n";
       return 0;
   }
 #+end_src

 #+RESULTS:
 : 2

*** DONE Основы объектно-ориентированного программирования
    CLOSED: [2021-06-15 Tue 18:51]
**** DONE 11)
     CLOSED: [2021-06-15 Tue 16:34]
     Описать класс “Прямоугольник”, который задан размерами двух его сторон. Описать
     конструктор по-умолчанию и конструктор с параметрами. Описать метод расчета
     площади. Показать пример использования.
     #+begin_src C++ :includes <iostream>
       class Box
       {
       private:
           int h, w;
       public:
           Box()
               : h(0), w(0)
           {}
           Box(int H, int W)
               : h(H), w(W)
           {}
           int ploshad()
           {
               return h*w; 
           }
       };

       int main()
       {
           Box one(10,5);
           int temp = one.ploshad();
           printf("%d\n", temp);
           Box two;
           temp = two.ploshad();
           printf("%d\n", temp);
       }
     #+end_src

     #+RESULTS:
     | 50 |
     |  0 |

**** DONE 12)
     CLOSED: [2021-06-15 Tue 16:34]
     Описать класс “Квартира”, которая задана площадью и размером квартплаты за
     квадратный метр. Описать конструктор по-умолчанию и конструктор с параметрами.
     Описать метод расчета квартплаты по тарифу. Показать пример использования.
     #+begin_src C++ :includes <iostream>
       // аналогично предыдущей
     #+end_src
**** DONE 13)
     CLOSED: [2021-06-15 Tue 16:34]
     Описать класс “Точка”, которая задана двумя целочисленными координатами
     (закрытые поля). Описать конструктор по-умолчанию и конструктор с параметрами.
     Описать метод нахождения расстояния до другой точки. (Расстояние равно корень суммы
     квадратов разниц между координатами) Показать пример использования.
     #+begin_src C++ :includes <iostream>
       // аналогично предыдущей
     #+end_src
**** DONE 14)
     CLOSED: [2021-06-15 Tue 16:34]
     Описать класс “Строка”, которая задана массивом символов и размером. Описать
     конструктор по-умолчанию и конструктор с параметрами. Размер - закрытое поле.
     Описать метод конкатенации двух строк. Показать пример использования.
     #+begin_src C++ :includes <iostream>
       class String
       {
       private:
           int size;
           char *str;
       public:
           String()
           {
               size = 1;
               str = nullptr;
               str = (char*)calloc(size, sizeof(char));
           }
           String(char* Str, int Size)
               : size(Size)
           {
               str = nullptr;
               str = (char*)calloc(size, sizeof(char));
               for(int i=0; i<size; i++)
                   str[i] = Str[i];
           }

           void conc(String one, String two)
           {
               size = one.get_size() + two.get_size();
               int i = 0;
               str = (char*)realloc(str, size*sizeof(char));

               for(i=0; i<one.get_size(); i++)
                   str[i] = one.get_char(i);
               for(i; i<size; i++)
                   str[i] = two.get_char(i-one.get_size());
           }

           int get_size()
           {
               return size;
           }

           char get_char(int i)
           {
               return str[i];
           }

           char* get_str()
           {
               return str;   
           }
       };

       int main()
       {
           char *_one = "hi",
               ,*_two = "hi";

           String one(_one, 2);
           String two(_two, 2);
           String _new;
           _new.conc(one, two);
           printf("%s", _new.get_str());
           return 0;
       }
     #+end_src

     #+RESULTS:
     |    4 |
     |    2 |
     | hihi |

**** DONE 15)
     CLOSED: [2021-06-15 Tue 18:51]
     Описать класс “Вектор”, который задан целочисленным массивом и размером.
     Описать конструктор по-умолчанию и конструктор с параметрами. Размер - закрытое
     поле. Описать метод расширения вектора (метод принимает число на которое нужно
     расширить размер массива, старые данные в массиве сохраняются). Показать пример
     использования.
     #+begin_src C++ :includes <iostream>
       // аналогично предыдущей
       using namespace std;

       class Vector
       {
           private:
           int Size,
               ,*arr;
           public:
           Vector()
           {
               Size=0;
               arr = nullptr;
               arr = new int[Size];
           }

           Vector(int Size, int *arr)
           {
               this->Size = Size;
               this->arr = arr;
           }

           void _resize(int plass)
           {
               this->Size += plass;
               int *temp = nullptr;
               temp = new int[Size];
               for(int i=0; i<Size-plass; i++)
                   {
                       temp[i] = arr[i];
                   }
               delete []arr;
               arr = nullptr;
               arr = new int[Size];
               for(int i=0; i<Size; i++)
                   {
                       arr[i] = temp[i];
                   }
           }

           void _print()
               {
                   for(int i=0; i<Size; i++)
                       {
                           cout << arr[i] << " ";
                       }
               }

       };

       int main()
       {
           int *temp = nullptr;
           temp = new int[4];
           for(int i=0; i<4; i++)
               temp[i] = i;
           Vector vctr(4, temp);
           vctr._print();
           cout << "\n";
           vctr._resize(5);
           vctr._print();
           cout << "\n";
       }
     #+end_src

     #+RESULTS:
     | 0 | 1 | 2 | 3 |   |   |   |   |   |
     | 0 | 1 | 2 | 3 | 0 | 0 | 0 | 0 | 0 |

*** DONE Динамические структуры данных
    CLOSED: [2021-06-15 Tue 21:43]
**** DONE 16)
     CLOSED: [2021-06-15 Tue 16:33]
     Описать класс элемента двусвязного списка и класс самого списка. Описать метод
     добавления элемента в конец списка.
     #+begin_src C++ :includes <iostream>
       class List
       {
       public:
           List()
           {
               Size = 0;
               head = nullptr;
               tail = nullptr;
           }

           void push_back(int date)    // добавление в конец списка
           {
               Size++;
               if(head == nullptr)     // если начала нет, то создаем
                   { 
                       head = new Node(date);
                       tail = head;
                   }
               else                    // если есть, то в конец добавляем узел
                   {
                       Node *current = this->tail;
                       current->pNext = new Node(date);
                       tail = current->pNext; 
                       tail->pPrev = current; // добавляем указатель на предыдуший узел
                   }
           }

           void _print_next()          // вывод с начала
           {
               Node *current = this->head;
               for(int i=0; i<Size; i++)
                   {
                       std::cout << current->date << " ";
                       current = current->pNext;
                   }
           }

           void _print_tail()           // вывод с конца
           {
               Node *current = this->tail;
               for(int i=0; i<Size; i++)
                   {
                       std::cout << current->date << " ";
                       current = current->pPrev;
                   }
           }



       private:
           class Node                  // создаем класс узла списка
           {
           public:
               Node *pNext;            // след узел
               Node *pPrev;            // предыдуший узел
               int date;
               Node(int date = 0, Node *pNext = nullptr, Node *pPrev = nullptr)
               {
                   this->date = date;
                   this->pNext = pNext;
                   this->pPrev = pPrev;
               }
           };
           int Size;
           Node *head;                 // начало списка
           Node *tail;                 // конец списка
       };


       int main()
       {
           List one;
           one.push_back(5);
           one.push_back(6);
           one.push_back(5);
           one.push_back(6);
           one._print_next();
           std::cout << std::endl;
           one._print_tail();
           return 0;
       }
     #+end_src

     #+RESULTS:
     | 5 | 6 | 5 | 6 |
     | 6 | 5 | 6 | 5 |

**** DONE 17)
     CLOSED: [2021-06-15 Tue 16:33]
     Описать класс элемента двусвязного списка и класс самого списка. Описать метод
     поиска элемента в списке по индексу. Метод должен возвращать указатель на элемент
     списка.
     #+begin_src C++ :includes <iostream>
       class Node                      // здесь Node я вынес чтобы можно было вернуть указатель на узел
       {
       public:
           Node *pNext;
           Node *pPrev;
           int date;
           Node(int date = 0, Node *pNext = nullptr, Node *pPrev = nullptr)
           {
               this->date = date;
               this->pNext = pNext;
               this->pPrev = pPrev;
           }
       };

       class List
       {
       public:
           List()
           {
               Size = 0;
               head = nullptr;
               tail = nullptr;
           }

           void push_back(int date)
           {
               Size++;
               if(head == nullptr)
                   {
                       head = new Node(date);
                       tail = head;
                   }
               else
                   {
                       Node *current = this->tail;
                       current->pNext = new Node(date);
                       tail = current->pNext;
                       tail->pPrev = current;
                   }
           }

           Node *_search(int ind)
           {
               if(ind < Size)
                   {
                       Node *current = this->head;    // указываем на начало
                       for(int i=0; i<ind; i++) // просто идем до нужного узла
                           {
                               current = current->pNext;
                           }
                       return current;
                   }
           }

           void print_srh(int ind)
           {
               _search(ind);
           }
       private:    
           int Size;
           Node *head;
           Node *tail;
       };


       int main()
       {
           List one;
           one.push_back(5);           // 0
           one.push_back(6);           // 1
           one.push_back(7);           // 2
           one.push_back(5);           // ...
           one.push_back(6);
           Node *temp = one._search(0);
           std::cout << temp->date << " ";
           return 0;
       }
     #+end_src

     #+RESULTS:
     : 5

**** DONE 18)
     CLOSED: [2021-06-15 Tue 16:33]
     Описать класс элемента двусвязного списка и класс самого списка. Описать метод
     удаления элемента в списке по индексу.
     #+begin_src C++ :includes <iostream>
       class List
       {
       public:
           List()
           {
               Size = 0;
               head = nullptr;
               tail = nullptr;
           }

           void push_back(int date)
           {
               Size++;
               if(head == nullptr)
                   {
                       head = new Node(date);
                       tail = head;
                   }
               else
                   {
                       Node *current = this->tail;
                       current->pNext = new Node(date);
                       tail = current->pNext;
                       tail->pPrev = current;
                   }
           }


           void _dell(int ind)
           {
               Node *current = this->head;    // указываем на начало
               for(int i=0; i<ind; i++) // просто идем до нужного узла
                   {
                       current = current->pNext;
                   }
               if(current == this->head)
                   {
                       head = current->pNext;
                       head->pPrev = nullptr;
                   }
               else if(current == this->tail)
                   {
                       tail = current->pPrev;
                       tail->pNext = nullptr;
                   }
               else
                   {
                       Node *prev = current->pPrev,
                           ,*next = current->pNext; 
                       prev->pNext = current->pNext;
                       next->pPrev = current->pPrev;
                   }
               Size--;
           }

           void _print()
           {
               Node *current = this->head;
               for(int i=0; i<Size; i++)
                   {
                       printf("%d ", current->date);
                       current = current->pNext;                    
                   }
           }

       private:
           class Node
           {
           public:
               int date;
               Node *pNext;
               Node *pPrev;
               Node(int date = 0, Node *pNext = nullptr, Node *pPrev = nullptr)
               {
                   this->date = date;
                   this->pNext = pNext;
                   this->pPrev = pPrev;
               }
           };
           int Size;
           Node *head;
           Node *tail;
       };

       int main()
       {
           List one;
           one.push_back(5);           // 0
           one.push_back(6);           // 1
           one.push_back(7);           // 2
           one.push_back(5);           // ...
           one.push_back(6);
           one._print();
           printf("\n");
           one._dell(2);
           one._print();
           printf("\n");
           return 0;
       }
     #+end_src

     #+RESULTS:
     | 5 | 6 | 7 | 5 | 6 |
     | 5 | 6 | 5 | 6 |   |

**** DONE 19)
     CLOSED: [2021-06-15 Tue 21:10]
     Описать класс элемента двусвязного списка и класс самого списка. Описать метод
     сортировки по одному из информационных полей элемента двусвязного списка.
 #+begin_src C++ :includes <iostream>
 //я не сделал выбор по какому полю сравнивать
   class List
     {
     public:
         List()
         {
             head = nullptr;
             tail = nullptr;
             Size = 0;
         }

         void push_back(int date)
         {
             Size++;
             if(head == nullptr)
                 {
                     head = new Node(date);
                     tail = head;
                 }
             else
                 {
                     Node *current = this->tail;
                     current->pNext = new Node(date);
                     tail = current->pNext;
                     tail->pPrev = current;
                 }
         }

         void _sort(int N_date)
         {
             int swapped, i;
             Node *ptr1;
             Node *lptr = NULL;
             /* Проверка на пустой список */
             if (this->head == NULL)
                 return;
             do
                 {
                     swapped = 0;
                     ptr1 = this->head;
                     while (ptr1->pNext != lptr)
                         {
                             if (ptr1->date > ptr1->pNext->date)
                                 {
                                     int temp = ptr1->date;
                                     ptr1->date = ptr1->pNext->date;
                                     ptr1->pNext->date = temp;
                                     swapped = 1;
                                 }
                             ptr1 = ptr1->pNext;
                         }
                     lptr = ptr1;
                 }
             while (swapped);
         }



         void _print()
         {
             Node *current = this->head;
             for(int i=0; i<Size; i++)
                 {
                     printf("%d ", current->date);
                     current = current->pNext;                    
                 }
         }


     private:
         class Node
         {
         public:
             Node *pNext;
             Node *pPrev;
             int date;
             Node(int date=0, Node *pNext=nullptr, Node *pPrev=nullptr)
             {
                 this->date = date;
                 this->pNext = pNext;
                 this->pPrev = pPrev;
             }
         };
         Node *head;
         Node *tail;
         int Size;

     };


     int main()
     {
         List one;
         one.push_back(5);           // 0
         one.push_back(6);           // 1
         one.push_back(7);           // 2
         one.push_back(4);           // ...
         one.push_back(1);
         one._print();
         printf("\n");
         one._sort(0);
         one._print();
         printf("\n");
         return 0;
     }
 #+end_src

 #+RESULTS:
 | 5 | 6 | 7 | 4 | 1 |
 | 1 | 4 | 5 | 6 | 7 |

**** DONE 20)
     CLOSED: [2021-06-15 Tue 21:41]
     Описать класс элемента двусвязного списка и класс самого списка. Описать метод
     добавления элемента в список после заданного индекса.
     #+begin_src C++ :includes <iostream>
             class List
             {
             public:
                 List()
                 {
                     Size = 0;
                     head = nullptr;
                     tail = nullptr;
                 }

                 void push_back(int date)    // добавление в конец списка
                 {
                     Size++;
                     if(head == nullptr)     // если начала нет, то создаем
                         { 
                             head = new Node(date);
                             tail = head;
                         }
                     else                    // если есть, то в конец добавляем узел
                         {
                             Node *current = this->tail;
                             current->pNext = new Node(date);
                             tail = current->pNext; 
                             tail->pPrev = current; // добавляем указатель на предыдуший узел
                         }
                 }

                 void push_ind(int ind, int date)    // добавление в конец списка
                 {
                     if(ind >= Size || head == nullptr || ind < 0)
                         return;
                     Size++;
                     // если есть, то в конец добавляем узел
           
                     Node *current = this->head;
                     for(int i=0; i<ind; i++)
                         {
                             current = current->pNext;
                         }
                     Node *temp_Next = current->pNext,
                         ,*temp = new Node(date);
                     temp->pPrev = current;
                     temp->pNext = temp_Next;
                     temp_Next->pPrev = temp;
                     current->pNext = temp;
                     if(current == tail)
                         tail = temp;
            
                 }

                 void _print_next()          // вывод с начала
                 {
                     Node *current = this->head;
                     for(int i=0; i<Size; i++)
                         {
                             std::cout << current->date << " ";
                             current = current->pNext;
                         }
                 }

                 void _print_tail()           // вывод с конца
                 {
                     Node *current = this->tail;
                     for(int i=0; i<Size; i++)
                         {
                             std::cout << current->date << " ";
                             current = current->pPrev;
                         }
                 }



             private:
                 class Node                  // создаем класс узла списка
                 {
                 public:
                     Node *pNext;            // след узел
                     Node *pPrev;            // предыдуший узел
                     int date;
                     Node(int date = 0, Node *pNext = nullptr, Node *pPrev = nullptr)
                     {
                         this->date = date;
                         this->pNext = pNext;
                         this->pPrev = pPrev;
                     }
                 };
                 int Size;
                 Node *head;                 // начало списка
                 Node *tail;                 // конец списка
             };


             int main()
             {
                 List one;
                 one.push_back(1);
                 one.push_back(2);
                 one.push_back(3);
                 one.push_back(4);
                 one._print_next();
                 std::cout << std::endl;
                 one.push_ind(1, 0);
                 one._print_next();
                 return 0;
             }
     #+end_src

     #+RESULTS:
     | 1 | 2 | 3 | 4 |   |
     | 1 | 2 | 0 | 3 | 4 |

*** DONE Стандартная библиотека шаблонов
    CLOSED: [2021-06-15 Tue 18:51]
**** DONE 21)
     CLOSED: [2021-06-15 Tue 17:05]
     Написать фрагмент кода, который делит строку string на слова по пробелам. Результат
     - список (std::list) слов типа std::string.
     #+begin_src C++ 
       #include <iostream>
       #include <sstream>
       #include <list>




       int main()
       {
           std::string str = "Hello, World!!!";
           std::stringstream ss(str);
           std::list<std::string> lst;
           while(ss)
               {
                   ss >> str;
                   if(str != "\0")
                       lst.push_back(str);
                   str = "\0";
               }
           for(auto i=lst.begin(); i!=lst.end(); i++)
               {
                   std::cout << *i << "\n"; 
               }
           return 0;
       }
     #+end_src

     #+RESULTS:
     | Hello,   |
     | World!!! |

**** DONE 22)
     CLOSED: [2021-06-15 Tue 17:23]
     Написать фрагмент кода, который сортирует список (std::list) целых чисел.
     #+begin_src C++
       #include <iostream>
       #include <list>


       int main()
       {
           std::list lst = {1, 5, 3, 6, 2};
           for(auto iter = lst.begin(); iter != lst.end(); iter++)
               {
                   std::cout << *iter << " ";
               }
           std::cout << "\n";

           lst.sort();
           for(auto iter = lst.begin(); iter != lst.end(); iter++)
               {
                   std::cout << *iter << " ";
               }
           std::cout << "\n";
           return 0;
       }
     #+end_src 

     #+RESULTS:
     | 1 | 5 | 3 | 6 | 2 |
     | 1 | 2 | 3 | 5 | 6 |

**** DONE 23)
     CLOSED: [2021-06-15 Tue 17:32]
     Написать фрагмент кода, который позволяет найти самое длинное слово в строке
     std::string. Слова отделены пробелами. Результат - слово, являющееся переменной типа
     std::string.
     #+begin_src C++
       #include <iostream>
       #include <sstream>

       using namespace std;

       int main()
       {
           string str = "Hi my world";
           stringstream ss(str);
           string word;
           while(ss)
               {
                   ss >> str;
                   if(word.size() < str.size())
                       word = str;
                   str = "\0";
               }
           cout << word << endl;

           return 0;
       }
     #+end_src

     #+RESULTS:
     : world

**** DONE 24)
     CLOSED: [2021-06-15 Tue 17:48]
     Имеется два списка std::list содержащих целые числа. Написать фрагмент кода,
     который формирует третий список std::list, состоящий из элементов, которые содержат
     оба из них.
 #+begin_src C++
   #include <iostream>
   #include <list>

   using namespace std;

   int main()
   {
       list<int> list1 = { 5,9,0,1,3,4 };
       list<int> list2 = { 8,7,2,6,4 }; 
       list1.sort();
       list2.sort();
       list1.merge(list2);
       //list1.unique();                // если нужно убать повторения
       cout << "merged: ";
       for(auto i=list1.begin(); i!=list1.end(); i++)
           {
               cout << *i << " ";
           }
       return 0;
   }
 #+end_src

 #+RESULTS:
 : merged: 0 1 2 3 4 5 6 7 8 9

**** DONE 25)
     CLOSED: [2021-06-15 Tue 17:56]
     Имеется строка типа std::string. Строка содержит слова, разделенные пробелами.
     Написать фрагмент кода, который формирует строку, составленную из первых букв слов
     исходной строки.
 #+begin_src C++
   #include <iostream>
   #include <sstream>

   using namespace std;

   int main()
   {
       string str = "Hello my world";
       stringstream ss(str);
       string temp;
       while(ss)
           {
               ss >> str;
               if(str != "\0")
                   temp = temp + str[0];
               str = "\0";
           }
       cout << temp;
       return 0;
   }
 #+end_src

 #+RESULTS:
 : Hmw

*** DONE Связи
    CLOSED: [2021-06-15 Tue 22:24]
**** DONE 26)
     CLOSED: [2021-06-15 Tue 16:32]
     Опишите два класса таким образом, чтобы они имели отношение агрегации.
     Нарисуйте диаграмму. Поясните понятие агрегации.

     Агрегация – это когда экземпляр двигателя создается где-то в другом месте кода, и передается в конструктор автомобиля в качестве параметра.

     В объектно-ориентированном программировании под агрегированием (или как его еще называют - делегированием) подразумевают методику создания нового класса из уже существующих классов путём их включения. 
     Об агрегировании также часто говорят как об «отношении принадлежности» по принципу «у машины есть корпус, колёса и двигатель».

     #+begin_src C++ :includes <iostream> 
       class One
       {
       private:
           int i;
       public:
           One(int A=0): i(A)
           {}
           void input()
           {
               printf("%d\n", i);
           }
       };

       class Two
       {
       private:
           One *j;
       public:
           Two(One *A = nullptr): j(A) 
           {}
           void input()
           {
               j[0].input();
           }
       };

       int main()
       {
           One *new_one = new One(1);
           Two new_two(new_one);
           new_two.input();
           return 0;
       }
     #+end_src

     #+RESULTS:
     : 1

**** DONE 27)
     CLOSED: [2021-06-15 Tue 16:32]
     Опишите два класса таким образом, чтобы они имели отношение композиции.
     Нарисуйте диаграмму. Поясните понятие композиции.

     Композиция – это когда двигатель не существует отдельно от автомобиля. Он создается при создании автомобиля и полностью управляется автомобилем. В типичном примере, экземпляр двигателя будет создаваться в конструкторе автомобиля.

     #+begin_src C++ :includes <iosstream>
       class Engine
       {
       private:
           int power;
       public:
           Engine(int p)
           {
               power = p;
           }
       };

       class Car
       {
       private:
           string model = "Porshe";
           Engine engine;
       public:
           Car()
           {
               this.engine = new Engine(360);
           }
       };
     #+end_src

**** DONE 28)
     CLOSED: [2021-06-15 Tue 16:32]
     Опишите два класса таким образом, чтобы они имели отношение зависимости.
     Нарисуйте диаграмму. Поясните понятие зависимости.
     #+begin_src C++
       #include <iostream>

       class Point
       {
       private:
           double m_x, m_y, m_z;

       public:
           Point(double x=0.0, double y=0.0, double z=0.0): m_x(x), m_y(y), m_z(z)
           {
           }

           friend std::ostream& operator<< (std::ostream &out, const Point &point);
       };

       std::ostream& operator<< (std::ostream &out, const Point &point)
       {
           // Поскольку функция перегрузки operator<< является дружественной классу Point, то мы имеем прямой доступ к закрытым членам класса Point
           out << "Point(" << point.m_x << ", " << point.m_y << ", " << point.m_z << ")";

           return out;
       }

       int main()
       {
           Point point1(5.0, 6.0, 7.0);

           std::cout << point1;

           return 0;
       }
     #+end_src
**** DONE 29)
     CLOSED: [2021-06-15 Tue 22:17]
     Опишите два класса таким образом, чтобы они имели отношение бинарной
     ассоциации. Нарисуйте диаграмму. Поясните понятие ассоциации.
 Каждому сотруднику может соответствовать только одна идентификационная карточка, мощность связи 1 к 1.
 #+begin_src C++
   class A
   {
       private:
       int a;
       int b;
       public:
       A()
       {
           a = b = 0;
       }

   };

   class B
   {
       private:
       A one;                      // мы можем использовать A только 1 раз

       B()
       {}
       B(A one = A())
       {
           this->one = one;
       }
   };

 #+end_src

 #+RESULTS:

**** DONE 30)
     CLOSED: [2021-06-15 Tue 22:24]
     Опишите два класса таким образом, чтобы они имели отношение N-арной ассоциации.
     Нарисуйте диаграмму. Поясните понятие ассоциации

 Каждому объекты работник(Employee) может соответствовать несколько рабочих помещений. Мощность связи один-ко-многим.
 #+begin_src C++
   class A
   {
       private:
       int i;
       public:
       A()
       {
           i = 0;
       }
   };


   class B
   {
       private:
       A *one;
       public:
       B(A *one=nullptr)
       {
           this->one = one;
       }
   };
 #+end_src

 #+RESULTS:
     
