** DONE Блок задач первого семестра
   CLOSED: [2021-06-15 Tue 20:07]
*** DONE 1)
    CLOSED: [2021-06-15 Tue 16:33]
    Оформить в виде функции фрагмент программы, меняющий местами максимальный и
    минимальный элементы целочисленного массива. Массив передать в функцию через
    параметры функции.
    #+begin_src C++ :includes <iostream> 
      int* h(int* mas, int size)
      {
          int max = 0,
              min = 9999;
          bool max_end = false,
              min_end = false;
          for(int i=0; i<size; i++)
              {
                  if(mas[i] > max)
                      {
                          max = mas[i];
                      }
                  if(mas[i] < min)
                      {
                          min = mas[i];
                      }
              }
          for(int i=0; i<size; i++)
              {
                  if(mas[i] == max && !max_end)
                      {
                          mas[i] = min;
                          max_end = true;
                          continue;
                      }
                  if(mas[i] == min && !min_end)
                      {
                          mas[i] = max;
                          min_end = true;
                          continue;
                      }
              } 
          return mas;
      }

      int main()
      {
          int *mas = NULL,
              size = 5;
          mas = (int*)calloc(size, sizeof(int));
          for(int i=0; i<size; i++)
              {
                  mas[i] = i;
              }
          mas[1] = 4;
          h(mas, size);
          return 0;

      }
    #+end_src

    #+RESULTS:
*** DONE 2)
    CLOSED: [2021-06-15 Tue 16:33]
    Написать фрагмент программы, выводящий на экран элементы массива целых чисел,
    превышающих среднее арифметическое всех элементов. Поиск среднего арифметического
    оформить в виде отдельной функции.
    #+begin_src C++ :includes <iostream> 
      int h(int* mas, int size)
      {
          int sa = 0;
          for(int i=0; i<size; i++)
              {
                  sa += mas[i];
              }
          sa /= size;
          return sa;
      }

      int main()
      {
          int *mas = NULL,
              size = 5,
              sa = 0;
          mas = (int*)calloc(size, sizeof(int));
          for(int i=0; i<size; i++)
              {
                  mas[i] = i;
              }
          sa = h(mas, size);
          for(int i=0; i<size; i++)
              {
                  if(mas[i] > sa)
                      {
                          printf("%d ", mas[i]);   
                      }
              }
          return 0;

      }
    #+end_src

    #+RESULTS:
    : 3 4

*** DONE 3)
    CLOSED: [2021-06-15 Tue 16:33]
    Написать фрагмент программы, удаляющий i-й элемент из массива целых чисел
    размера N, i <= N. Фрагмент оформить в виде функции, массив передать в функцию через
    параметры.
    #+begin_src C++ :includes <iostream> 
      int* h(int* mas, int &size, int f)
      {
          int *temp = NULL,
              k = 0;
          temp = (int*)calloc(size-1, sizeof(int));
          for(int i=0; i<size; i++)
              {
                  if(i != f)
                      {
                          temp[k] = mas[i];
                          k++;
                      }
              }
          size -= 1;
          return temp;
      }

      int main()
      {
          int *mas = NULL,
              size = 5;
          mas = (int*)calloc(size, sizeof(int));
          for(int i=0; i<size; i++)
              {
                  mas[i] = i;
              }
          mas = h(mas, size, 1);
          for(int i=0; i<size; i++)
              printf("%d ", mas[i]);
          return 0;

      }
    #+end_src

    #+RESULTS:
    : 0 2 3 4

*** DONE 4)
    CLOSED: [2021-06-15 Tue 16:33]
    Написать фрагмент программы, находящий в одномерном массиве, состоящем из n
    вещественных элементов, среднее значение всех элементов и заменяющий им
    наименьший элемент.
    #+begin_src C++ :includes <iostream> 
      int h(int* mas, int size)
      {
          int sa = 0;
          for(int i=0; i<size; i++)
              {
                  sa += mas[i];
              }
          sa /= size;
          return sa;
      }

      int main()
      {
          int *mas = NULL,
              size = 5,
              sa = 0,
              min = 9999;
          mas = (int*)calloc(size, sizeof(int));
          for(int i=0; i<size; i++)
              {
                  mas[i] = i;
              }
          sa = h(mas, size);
          for(int i=0; i<size; i++)
              {
                  if(mas[i] < min)
                      {
                          min = mas[i];
                      }
              }
          for(int i=0; i<size; i++)
              {
                  if(mas[i] == min)
                      {
                          mas[i] = sa;
                          break;
                      }
              }

          for(int i=0; i<size; i++)
              printf("%d ", mas[i]);
          return 0;

      }
    #+end_src

    #+RESULTS:
    : 2 1 2 3 4

*** DONE 5)
    CLOSED: [2021-06-15 Tue 16:33]
    Дана строка (Си-строка), содержащая текст. Написать фрагмент программы,
    выводящий на экран встречающиеся в строке цифры.
    #+begin_src C++ :includes <iostream>, <cstring>
      int main()
      {
          char str[] = "AES512 is good";

          char num[] = "0123456789";
          printf("%s\n", str);
          for(int i=0; i<strlen(str); i++)
              {
                  for(int j=0; j<10; j++)
                      {
                          if(str[i] == num[j])
                              std::cout << str[i] << " ";
                      }
              }
          std::cout << std::endl;
          return 0;
      }
    #+end_src

    #+RESULTS:
    | AES512 | is | good |
    |      5 |  1 |    2 |

*** DONE 6)
    CLOSED: [2021-06-15 Tue 19:16]
    Написать фрагмент программы для транспонирования прямоугольной матрицы.
    (Двумерный динамический массив)
#+begin_src C++ :includes <iostream>
  #include <iostream>

  using namespace std;

  int main()
  {
      int size_h = 3,
          size_w = 2;
      int Matrix[size_h][size_w] = {
          { 1, 2},
          { 2, 4},
          { 3, 6}
      };

      for(int i=0; i<size_h; i++)
          {
              for(int j=0; j<size_w; j++)
                  {
                      cout << Matrix[i][j] << " ";
                  }
              cout << "\n";
          }

      int **T_Matrix = nullptr;
      T_Matrix = new int*[size_w];
      for(int i=0; i<size_h; i++)
          {
              T_Matrix[i] = new int[size_w];
          }
      for(int i=0; i<size_w; i++)
          {
              for(int j=0; j<size_h; j++)
                  {
                      T_Matrix[i][j] = Matrix[j][i];
                  }  
          }
      for(int i=0; i<size_w; i++)
          {
              for(int j=0; j<size_h; j++)
                  {
                      cout << T_Matrix[i][j] << " ";
                  }
              cout << "\n";
          }

  }
#+end_src

#+RESULTS:
| 1 | 2 |   |
| 2 | 4 |   |
| 3 | 6 |   |
| 1 | 2 | 3 |
| 2 | 4 | 6 |

*** DONE 7)
    CLOSED: [2021-06-15 Tue 19:26]
    Написать фрагмент программы, определяющий, является ли произвольная
    прямоугольная матрица симметричной относительно главной диагонали. (Двумерный
    динамический массив)
#+begin_src C++ :includes <iostream>
  #include <iostream>

  using namespace std;

  int main()
  {
      int size_h = 3,
          size_w = 3;
      int Matrix[size_h][size_w] = {
          { 1, 1, 3},
          { 2, 4, 1},
          { 3, 1, 2}
      };

      for(int i=0; i<size_h; i++)
          {
              for(int j=0; j<size_w; j++)
                  {
                      cout << Matrix[i][j] << " ";
                  }
              cout << "\n";
          }
      if(size_h != size_w)
          {
              printf("no\n");
              return 0;
          }
    
      int **T_Matrix = nullptr;
      T_Matrix = new int*[size_w];
      for(int i=0; i<size_h; i++)
          {
              T_Matrix[i] = new int[size_w];
          }
      for(int i=0; i<size_w; i++)
          {
              for(int j=0; j<size_h; j++)
                  {
                      T_Matrix[i][j] = Matrix[j][i];
                  }  
          }
      cout << "\n";
      for(int i=0; i<size_w; i++)
          {
              for(int j=0; j<size_h; j++)
                  {
                      cout << T_Matrix[i][j] << " ";
                  }
              cout << "\n";
          }
      for(int i=0; i<size_w; i++)
          {
              for(int j=0; j<size_h; j++)
                  {
                      if(Matrix[i][j] != T_Matrix[i][j])
                          {
                              printf("no\n");
                              return 0;
                          }
                  }
          }
      printf("yes\n");
      return 0;
  }
#+end_src

#+RESULTS:
|  1 | 1 | 3 |
|  2 | 4 | 1 |
|  3 | 1 | 2 |
|    |   |   |
|  1 | 2 | 3 |
|  1 | 4 | 1 |
|  3 | 1 | 2 |
| no |   |   |

*** DONE 8)
    CLOSED: [2021-06-15 Tue 19:36]
    Написать фрагмент программы, заменяющий в произвольной квадратной матрице
    строку с минимальным элементом матрицы нулями. (Двумерный динамический массив)
#+begin_src C++ :includes <iostream>
  int size = 3;
  int min = 9999, min_str = 0;
  int Matrix[size][size] =
      {
          {1, 2, 3},
          {1, -1, 3},
          {1, 0, 3}
      };

  for(int i=0; i<size; i++)
      {
          for(int j=0; j<size; j++)
              {
                  if(min > Matrix[i][j])
                      {
                          min = Matrix[i][j];
                          min_str = i;
                      }
              }
      }

  for(int i=0; i<size; i++)
      {
          Matrix[min_str][i] = 0;
      }

  for(int i=0; i<size; i++)
      {
          for(int j=0; j<size; j++)
              {
                  std::cout << Matrix[i][j] << " ";
              }
          std::cout << "\n";
      }

#+end_src

#+RESULTS:
| 1 | 2 | 3 |
| 0 | 0 | 0 |
| 1 | 0 | 3 |

*** DONE 9)
    CLOSED: [2021-06-15 Tue 19:54]
    Дана целочисленная прямоугольная матрица. Написать фрагмент программы,
    определяющей количество столбцов, содержащих хотя бы один нулевой элемент.
    Оформить в виде функции. (Двумерный динамический массив)
#+begin_src C++ :includes <iostream>
  int col(int **mas, int size_h, int size_w)
  {
      int many = 0;
      for(int i=0; i<size_h; i++)
          {
              for(int j=0; j<size_w; j++)
                  {
                      if(mas[j][i] == 0)
                          {
                              many++;
                              break;
                          }
                  }
          }
      return many;
  }

  int main()
  {
      int size_h = 3;
      int size_w = 3;
      int Matrix[size_h][size_w] =
          {
              {1, 2, 3},
              {1, 1, 3},
              {0, 0, 3}
          };
      int** mas = new int*[size_w];
      for(int i = 0; i<size_w; i++)
      {
          mas[i] = &Matrix[i][0];
      }

      std::cout << col(mas, size_h, size_w) << "\n";
      return 0;
  }
#+end_src

#+RESULTS:
: 2

*** DONE 10)
    CLOSED: [2021-06-15 Tue 20:07]
    Дана целочисленная прямоугольная матрица. Написать фрагмент программы,
    определяющей количество строк, содержащих хотя бы один нулевой элемент.
    (Двумерный динамический массив)
#+begin_src C++ :includes <iostream>
  int col(int **mas, int size_h, int size_w)
  {
      int many = 0;
      for(int i=0; i<size_h; i++)
          {
              for(int j=0; j<size_w; j++)
                  {
                      if(mas[i][j] == 0)
                          {
                              many++;
                              break;
                          }
                  }
          }
      return many;
  }

  int main()
  {
      int size_h = 3;
      int size_w = 3;
      int Matrix[size_h][size_w] =
          {
              {1, 2, 0},
              {1, 1, 3},
              {2, 0, 3}
          };
      int** mas = new int*[size_w];
      for(int i = 0; i<size_w; i++)
      {
          mas[i] = &Matrix[i][0];
      }

      std::cout << col(mas, size_h, size_w) << "\n";
      return 0;
  }
#+end_src

#+RESULTS:
: 2

** DONE Основы объектно-ориентированного программирования
   CLOSED: [2021-06-15 Tue 18:51]
*** DONE 11)
    CLOSED: [2021-06-15 Tue 16:34]
    Описать класс “Прямоугольник”, который задан размерами двух его сторон. Описать
    конструктор по-умолчанию и конструктор с параметрами. Описать метод расчета
    площади. Показать пример использования.
    #+begin_src C++ :includes <iostream>
      class Box
      {
      private:
          int h, w;
      public:
          Box()
              : h(0), w(0)
          {}
          Box(int H, int W)
              : h(H), w(W)
          {}
          int ploshad()
          {
              return h*w; 
          }
      };

      int main()
      {
          Box one(10,5);
          int temp = one.ploshad();
          printf("%d\n", temp);
          Box two;
          temp = two.ploshad();
          printf("%d\n", temp);
      }
    #+end_src

    #+RESULTS:
    | 50 |
    |  0 |

*** DONE 12)
    CLOSED: [2021-06-15 Tue 16:34]
    Описать класс “Квартира”, которая задана площадью и размером квартплаты за
    квадратный метр. Описать конструктор по-умолчанию и конструктор с параметрами.
    Описать метод расчета квартплаты по тарифу. Показать пример использования.
    #+begin_src C++ :includes <iostream>
      // аналогично предыдущей
    #+end_src
*** DONE 13)
    CLOSED: [2021-06-15 Tue 16:34]
    Описать класс “Точка”, которая задана двумя целочисленными координатами
    (закрытые поля). Описать конструктор по-умолчанию и конструктор с параметрами.
    Описать метод нахождения расстояния до другой точки. (Расстояние равно корень суммы
    квадратов разниц между координатами) Показать пример использования.
    #+begin_src C++ :includes <iostream>
      // аналогично предыдущей
    #+end_src
*** DONE 14)
    CLOSED: [2021-06-15 Tue 16:34]
    Описать класс “Строка”, которая задана массивом символов и размером. Описать
    конструктор по-умолчанию и конструктор с параметрами. Размер - закрытое поле.
    Описать метод конкатенации двух строк. Показать пример использования.
    #+begin_src C++ :includes <iostream>
      class String
      {
      private:
          int size;
          char *str;
      public:
          String()
          {
              size = 1;
              str = nullptr;
              str = (char*)calloc(size, sizeof(char));
          }
          String(char* Str, int Size)
              : size(Size)
          {
              str = nullptr;
              str = (char*)calloc(size, sizeof(char));
              for(int i=0; i<size; i++)
                  str[i] = Str[i];
          }

          void conc(String one, String two)
          {
              size = one.get_size() + two.get_size();
              int i = 0;
              str = (char*)realloc(str, size*sizeof(char));

              for(i=0; i<one.get_size(); i++)
                  str[i] = one.get_char(i);
              for(i; i<size; i++)
                  str[i] = two.get_char(i-one.get_size());
          }

          int get_size()
          {
              return size;
          }

          char get_char(int i)
          {
              return str[i];
          }

          char* get_str()
          {
              return str;   
          }
      };

      int main()
      {
          char *_one = "hi",
              ,*_two = "hi";

          String one(_one, 2);
          String two(_two, 2);
          String _new;
          _new.conc(one, two);
          printf("%s", _new.get_str());
          return 0;
      }
    #+end_src

    #+RESULTS:
    |    4 |
    |    2 |
    | hihi |

*** DONE 15)
    CLOSED: [2021-06-15 Tue 18:51]
    Описать класс “Вектор”, который задан целочисленным массивом и размером.
    Описать конструктор по-умолчанию и конструктор с параметрами. Размер - закрытое
    поле. Описать метод расширения вектора (метод принимает число на которое нужно
    расширить размер массива, старые данные в массиве сохраняются). Показать пример
    использования.
    #+begin_src C++ :includes <iostream>
      // аналогично предыдущей
      using namespace std;

      class Vector
      {
          private:
          int Size,
              ,*arr;
          public:
          Vector()
          {
              Size=0;
              arr = nullptr;
              arr = new int[Size];
          }

          Vector(int Size, int *arr)
          {
              this->Size = Size;
              this->arr = arr;
          }

          void _resize(int plass)
          {
              this->Size += plass;
              int *temp = nullptr;
              temp = new int[Size];
              for(int i=0; i<Size-plass; i++)
                  {
                      temp[i] = arr[i];
                  }
              delete []arr;
              arr = nullptr;
              arr = new int[Size];
              for(int i=0; i<Size; i++)
                  {
                      arr[i] = temp[i];
                  }
          }

          void _print()
              {
                  for(int i=0; i<Size; i++)
                      {
                          cout << arr[i] << " ";
                      }
              }

      };

      int main()
      {
          int *temp = nullptr;
          temp = new int[4];
          for(int i=0; i<4; i++)
              temp[i] = i;
          Vector vctr(4, temp);
          vctr._print();
          cout << "\n";
          vctr._resize(5);
          vctr._print();
          cout << "\n";
      }
    #+end_src

    #+RESULTS:
    | 0 | 1 | 2 | 3 |   |   |   |   |   |
    | 0 | 1 | 2 | 3 | 0 | 0 | 0 | 0 | 0 |

** DONE Динамические структуры данных
   CLOSED: [2021-06-15 Tue 21:43]
*** DONE 16)
    CLOSED: [2021-06-15 Tue 16:33]
    Описать класс элемента двусвязного списка и класс самого списка. Описать метод
    добавления элемента в конец списка.
    #+begin_src C++ :includes <iostream>
      class List
      {
      public:
          List()
          {
              Size = 0;
              head = nullptr;
              tail = nullptr;
          }

          void push_back(int date)    // добавление в конец списка
          {
              Size++;
              if(head == nullptr)     // если начала нет, то создаем
                  { 
                      head = new Node(date);
                      tail = head;
                  }
              else                    // если есть, то в конец добавляем узел
                  {
                      Node *current = this->tail;
                      current->pNext = new Node(date);
                      tail = current->pNext; 
                      tail->pPrev = current; // добавляем указатель на предыдуший узел
                  }
          }

          void _print_next()          // вывод с начала
          {
              Node *current = this->head;
              for(int i=0; i<Size; i++)
                  {
                      std::cout << current->date << " ";
                      current = current->pNext;
                  }
          }

          void _print_tail()           // вывод с конца
          {
              Node *current = this->tail;
              for(int i=0; i<Size; i++)
                  {
                      std::cout << current->date << " ";
                      current = current->pPrev;
                  }
          }



      private:
          class Node                  // создаем класс узла списка
          {
          public:
              Node *pNext;            // след узел
              Node *pPrev;            // предыдуший узел
              int date;
              Node(int date = 0, Node *pNext = nullptr, Node *pPrev = nullptr)
              {
                  this->date = date;
                  this->pNext = pNext;
                  this->pPrev = pPrev;
              }
          };
          int Size;
          Node *head;                 // начало списка
          Node *tail;                 // конец списка
      };


      int main()
      {
          List one;
          one.push_back(5);
          one.push_back(6);
          one.push_back(5);
          one.push_back(6);
          one._print_next();
          std::cout << std::endl;
          one._print_tail();
          return 0;
      }
    #+end_src

    #+RESULTS:
    | 5 | 6 | 5 | 6 |
    | 6 | 5 | 6 | 5 |

*** DONE 17)
    CLOSED: [2021-06-15 Tue 16:33]
    Описать класс элемента двусвязного списка и класс самого списка. Описать метод
    поиска элемента в списке по индексу. Метод должен возвращать указатель на элемент
    списка.
    #+begin_src C++ :includes <iostream>
      class Node                      // здесь Node я вынес чтобы можно было вернуть указатель на узел
      {
      public:
          Node *pNext;
          Node *pPrev;
          int date;
          Node(int date = 0, Node *pNext = nullptr, Node *pPrev = nullptr)
          {
              this->date = date;
              this->pNext = pNext;
              this->pPrev = pPrev;
          }
      };

      class List
      {
      public:
          List()
          {
              Size = 0;
              head = nullptr;
              tail = nullptr;
          }

          void push_back(int date)
          {
              Size++;
              if(head == nullptr)
                  {
                      head = new Node(date);
                      tail = head;
                  }
              else
                  {
                      Node *current = this->tail;
                      current->pNext = new Node(date);
                      tail = current->pNext;
                      tail->pPrev = current;
                  }
          }

          Node *_search(int ind)
          {
              if(ind < Size)
                  {
                      Node *current = this->head;    // указываем на начало
                      for(int i=0; i<ind; i++) // просто идем до нужного узла
                          {
                              current = current->pNext;
                          }
                      return current;
                  }
          }

          void print_srh(int ind)
          {
              _search(ind);
          }
      private:    
          int Size;
          Node *head;
          Node *tail;
      };


      int main()
      {
          List one;
          one.push_back(5);           // 0
          one.push_back(6);           // 1
          one.push_back(7);           // 2
          one.push_back(5);           // ...
          one.push_back(6);
          Node *temp = one._search(0);
          std::cout << temp->date << " ";
          return 0;
      }
    #+end_src

    #+RESULTS:
    : 5

*** DONE 18)
    CLOSED: [2021-06-15 Tue 16:33]
    Описать класс элемента двусвязного списка и класс самого списка. Описать метод
    удаления элемента в списке по индексу.
    #+begin_src C++ :includes <iostream>
      class List
      {
      public:
          List()
          {
              Size = 0;
              head = nullptr;
              tail = nullptr;
          }

          void push_back(int date)
          {
              Size++;
              if(head == nullptr)
                  {
                      head = new Node(date);
                      tail = head;
                  }
              else
                  {
                      Node *current = this->tail;
                      current->pNext = new Node(date);
                      tail = current->pNext;
                      tail->pPrev = current;
                  }
          }


          void _dell(int ind)
          {
              Node *current = this->head;    // указываем на начало
              for(int i=0; i<ind; i++) // просто идем до нужного узла
                  {
                      current = current->pNext;
                  }
              if(current == this->head)
                  {
                      head = current->pNext;
                      head->pPrev = nullptr;
                  }
              else if(current == this->tail)
                  {
                      tail = current->pPrev;
                      tail->pNext = nullptr;
                  }
              else
                  {
                      Node *prev = current->pPrev,
                          ,*next = current->pNext; 
                      prev->pNext = current->pNext;
                      next->pPrev = current->pPrev;
                  }
              Size--;
          }

          void _print()
          {
              Node *current = this->head;
              for(int i=0; i<Size; i++)
                  {
                      printf("%d ", current->date);
                      current = current->pNext;                    
                  }
          }

      private:
          class Node
          {
          public:
              int date;
              Node *pNext;
              Node *pPrev;
              Node(int date = 0, Node *pNext = nullptr, Node *pPrev = nullptr)
              {
                  this->date = date;
                  this->pNext = pNext;
                  this->pPrev = pPrev;
              }
          };
          int Size;
          Node *head;
          Node *tail;
      };

      int main()
      {
          List one;
          one.push_back(5);           // 0
          one.push_back(6);           // 1
          one.push_back(7);           // 2
          one.push_back(5);           // ...
          one.push_back(6);
          one._print();
          printf("\n");
          one._dell(2);
          one._print();
          printf("\n");
          return 0;
      }
    #+end_src

    #+RESULTS:
    | 5 | 6 | 7 | 5 | 6 |
    | 5 | 6 | 5 | 6 |   |

*** DONE 19)
    CLOSED: [2021-06-15 Tue 21:10]
    Описать класс элемента двусвязного списка и класс самого списка. Описать метод
    сортировки по одному из информационных полей элемента двусвязного списка.
#+begin_src C++ :includes <iostream>
//я не сделал выбор по какому полю сравнивать
  class List
    {
    public:
        List()
        {
            head = nullptr;
            tail = nullptr;
            Size = 0;
        }

        void push_back(int date)
        {
            Size++;
            if(head == nullptr)
                {
                    head = new Node(date);
                    tail = head;
                }
            else
                {
                    Node *current = this->tail;
                    current->pNext = new Node(date);
                    tail = current->pNext;
                    tail->pPrev = current;
                }
        }

        void _sort(int N_date)
        {
            int swapped, i;
            Node *ptr1;
            Node *lptr = NULL;
            /* Проверка на пустой список */
            if (this->head == NULL)
                return;
            do
                {
                    swapped = 0;
                    ptr1 = this->head;
                    while (ptr1->pNext != lptr)
                        {
                            if (ptr1->date > ptr1->pNext->date)
                                {
                                    int temp = ptr1->date;
                                    ptr1->date = ptr1->pNext->date;
                                    ptr1->pNext->date = temp;
                                    swapped = 1;
                                }
                            ptr1 = ptr1->pNext;
                        }
                    lptr = ptr1;
                }
            while (swapped);
        }



        void _print()
        {
            Node *current = this->head;
            for(int i=0; i<Size; i++)
                {
                    printf("%d ", current->date);
                    current = current->pNext;                    
                }
        }


    private:
        class Node
        {
        public:
            Node *pNext;
            Node *pPrev;
            int date;
            Node(int date=0, Node *pNext=nullptr, Node *pPrev=nullptr)
            {
                this->date = date;
                this->pNext = pNext;
                this->pPrev = pPrev;
            }
        };
        Node *head;
        Node *tail;
        int Size;

    };


    int main()
    {
        List one;
        one.push_back(5);           // 0
        one.push_back(6);           // 1
        one.push_back(7);           // 2
        one.push_back(4);           // ...
        one.push_back(1);
        one._print();
        printf("\n");
        one._sort(0);
        one._print();
        printf("\n");
        return 0;
    }
#+end_src

#+RESULTS:
| 5 | 6 | 7 | 4 | 1 |
| 1 | 4 | 5 | 6 | 7 |

*** DONE 20)
    CLOSED: [2021-06-15 Tue 21:41]
    Описать класс элемента двусвязного списка и класс самого списка. Описать метод
    добавления элемента в список после заданного индекса.
    #+begin_src C++ :includes <iostream>
            class List
            {
            public:
                List()
                {
                    Size = 0;
                    head = nullptr;
                    tail = nullptr;
                }

                void push_back(int date)    // добавление в конец списка
                {
                    Size++;
                    if(head == nullptr)     // если начала нет, то создаем
                        { 
                            head = new Node(date);
                            tail = head;
                        }
                    else                    // если есть, то в конец добавляем узел
                        {
                            Node *current = this->tail;
                            current->pNext = new Node(date);
                            tail = current->pNext; 
                            tail->pPrev = current; // добавляем указатель на предыдуший узел
                        }
                }

                void push_ind(int ind, int date)    // добавление в конец списка
                {
                    if(ind >= Size || head == nullptr || ind < 0)
                        return;
                    Size++;
                    // если есть, то в конец добавляем узел
           
                    Node *current = this->head;
                    for(int i=0; i<ind; i++)
                        {
                            current = current->pNext;
                        }
                    Node *temp_Next = current->pNext,
                        ,*temp = new Node(date);
                    temp->pPrev = current;
                    temp->pNext = temp_Next;
                    temp_Next->pPrev = temp;
                    current->pNext = temp;
                    if(current == tail)
                        tail = temp;
            
                }

                void _print_next()          // вывод с начала
                {
                    Node *current = this->head;
                    for(int i=0; i<Size; i++)
                        {
                            std::cout << current->date << " ";
                            current = current->pNext;
                        }
                }

                void _print_tail()           // вывод с конца
                {
                    Node *current = this->tail;
                    for(int i=0; i<Size; i++)
                        {
                            std::cout << current->date << " ";
                            current = current->pPrev;
                        }
                }



            private:
                class Node                  // создаем класс узла списка
                {
                public:
                    Node *pNext;            // след узел
                    Node *pPrev;            // предыдуший узел
                    int date;
                    Node(int date = 0, Node *pNext = nullptr, Node *pPrev = nullptr)
                    {
                        this->date = date;
                        this->pNext = pNext;
                        this->pPrev = pPrev;
                    }
                };
                int Size;
                Node *head;                 // начало списка
                Node *tail;                 // конец списка
            };


            int main()
            {
                List one;
                one.push_back(1);
                one.push_back(2);
                one.push_back(3);
                one.push_back(4);
                one._print_next();
                std::cout << std::endl;
                one.push_ind(1, 0);
                one._print_next();
                return 0;
            }
    #+end_src

    #+RESULTS:
    | 1 | 2 | 3 | 4 |   |
    | 1 | 2 | 0 | 3 | 4 |

** DONE Стандартная библиотека шаблонов
   CLOSED: [2021-06-15 Tue 18:51]
*** DONE 21)
    CLOSED: [2021-06-15 Tue 17:05]
    Написать фрагмент кода, который делит строку string на слова по пробелам. Результат
    - список (std::list) слов типа std::string.
    #+begin_src C++ 
      #include <iostream>
      #include <sstream>
      #include <list>




      int main()
      {
          std::string str = "Hello, World!!!";
          std::stringstream ss(str);
          std::list<std::string> lst;
          while(ss)
              {
                  ss >> str;
                  if(str != "\0")
                      lst.push_back(str);
                  str = "\0";
              }
          for(auto i=lst.begin(); i!=lst.end(); i++)
              {
                  std::cout << *i << "\n"; 
              }
          return 0;
      }
    #+end_src

    #+RESULTS:
    | Hello,   |
    | World!!! |

*** DONE 22)
    CLOSED: [2021-06-15 Tue 17:23]
    Написать фрагмент кода, который сортирует список (std::list) целых чисел.
    #+begin_src C++
      #include <iostream>
      #include <list>


      int main()
      {
          std::list lst = {1, 5, 3, 6, 2};
          for(auto iter = lst.begin(); iter != lst.end(); iter++)
              {
                  std::cout << *iter << " ";
              }
          std::cout << "\n";

          lst.sort();
          for(auto iter = lst.begin(); iter != lst.end(); iter++)
              {
                  std::cout << *iter << " ";
              }
          std::cout << "\n";
          return 0;
      }
    #+end_src 

    #+RESULTS:
    | 1 | 5 | 3 | 6 | 2 |
    | 1 | 2 | 3 | 5 | 6 |

*** DONE 23)
    CLOSED: [2021-06-15 Tue 17:32]
    Написать фрагмент кода, который позволяет найти самое длинное слово в строке
    std::string. Слова отделены пробелами. Результат - слово, являющееся переменной типа
    std::string.
    #+begin_src C++
      #include <iostream>
      #include <sstream>

      using namespace std;

      int main()
      {
          string str = "Hi my world";
          stringstream ss(str);
          string word;
          while(ss)
              {
                  ss >> str;
                  if(word.size() < str.size())
                      word = str;
                  str = "\0";
              }
          cout << word << endl;

          return 0;
      }
    #+end_src

    #+RESULTS:
    : world

*** DONE 24)
    CLOSED: [2021-06-15 Tue 17:48]
    Имеется два списка std::list содержащих целые числа. Написать фрагмент кода,
    который формирует третий список std::list, состоящий из элементов, которые содержат
    оба из них.
#+begin_src C++
  #include <iostream>
  #include <list>

  using namespace std;

  int main()
  {
      list<int> list1 = { 5,9,0,1,3,4 };
      list<int> list2 = { 8,7,2,6,4 }; 
      list1.sort();
      list2.sort();
      list1.merge(list2);
      //list1.unique();                // если нужно убать повторения
      cout << "merged: ";
      for(auto i=list1.begin(); i!=list1.end(); i++)
          {
              cout << *i << " ";
          }
      return 0;
  }
#+end_src

#+RESULTS:
: merged: 0 1 2 3 4 5 6 7 8 9

*** DONE 25)
    CLOSED: [2021-06-15 Tue 17:56]
    Имеется строка типа std::string. Строка содержит слова, разделенные пробелами.
    Написать фрагмент кода, который формирует строку, составленную из первых букв слов
    исходной строки.
#+begin_src C++
  #include <iostream>
  #include <sstream>

  using namespace std;

  int main()
  {
      string str = "Hello my world";
      stringstream ss(str);
      string temp;
      while(ss)
          {
              ss >> str;
              if(str != "\0")
                  temp = temp + str[0];
              str = "\0";
          }
      cout << temp;
      return 0;
  }
#+end_src

#+RESULTS:
: Hmw

** DONE Связи
   CLOSED: [2021-06-15 Tue 22:24]
*** DONE 26)
    CLOSED: [2021-06-15 Tue 16:32]
    Опишите два класса таким образом, чтобы они имели отношение агрегации.
    Нарисуйте диаграмму. Поясните понятие агрегации.

    Агрегация – это когда экземпляр двигателя создается где-то в другом месте кода, и передается в конструктор автомобиля в качестве параметра.

    В объектно-ориентированном программировании под агрегированием (или как его еще называют - делегированием) подразумевают методику создания нового класса из уже существующих классов путём их включения. 
    Об агрегировании также часто говорят как об «отношении принадлежности» по принципу «у машины есть корпус, колёса и двигатель».

    #+begin_src C++ :includes <iostream> 
      class One
      {
      private:
          int i;
      public:
          One(int A=0): i(A)
          {}
          void input()
          {
              printf("%d\n", i);
          }
      };

      class Two
      {
      private:
          One *j;
      public:
          Two(One *A = nullptr): j(A) 
          {}
          void input()
          {
              j[0].input();
          }
      };

      int main()
      {
          One *new_one = new One(1);
          Two new_two(new_one);
          new_two.input();
          return 0;
      }
    #+end_src

    #+RESULTS:
    : 1

*** DONE 27)
    CLOSED: [2021-06-15 Tue 16:32]
    Опишите два класса таким образом, чтобы они имели отношение композиции.
    Нарисуйте диаграмму. Поясните понятие композиции.

    Композиция – это когда двигатель не существует отдельно от автомобиля. Он создается при создании автомобиля и полностью управляется автомобилем. В типичном примере, экземпляр двигателя будет создаваться в конструкторе автомобиля.

    #+begin_src C++ :includes <iosstream>
      class Engine
      {
      private:
          int power;
      public:
          Engine(int p)
          {
              power = p;
          }
      };

      class Car
      {
      private:
          string model = "Porshe";
          Engine engine;
      public:
          Car()
          {
              this.engine = new Engine(360);
          }
      };
    #+end_src

*** DONE 28)
    CLOSED: [2021-06-15 Tue 16:32]
    Опишите два класса таким образом, чтобы они имели отношение зависимости.
    Нарисуйте диаграмму. Поясните понятие зависимости.
    #+begin_src C++
      #include <iostream>

      class Point
      {
      private:
          double m_x, m_y, m_z;

      public:
          Point(double x=0.0, double y=0.0, double z=0.0): m_x(x), m_y(y), m_z(z)
          {
          }

          friend std::ostream& operator<< (std::ostream &out, const Point &point);
      };

      std::ostream& operator<< (std::ostream &out, const Point &point)
      {
          // Поскольку функция перегрузки operator<< является дружественной классу Point, то мы имеем прямой доступ к закрытым членам класса Point
          out << "Point(" << point.m_x << ", " << point.m_y << ", " << point.m_z << ")";

          return out;
      }

      int main()
      {
          Point point1(5.0, 6.0, 7.0);

          std::cout << point1;

          return 0;
      }
    #+end_src
*** DONE 29)
    CLOSED: [2021-06-15 Tue 22:17]
    Опишите два класса таким образом, чтобы они имели отношение бинарной
    ассоциации. Нарисуйте диаграмму. Поясните понятие ассоциации.
Каждому сотруднику может соответствовать только одна идентификационная карточка, мощность связи 1 к 1.
#+begin_src C++
  class A
  {
      private:
      int a;
      int b;
      public:
      A()
      {
          a = b = 0;
      }

  };

  class B
  {
      private:
      A one;                      // мы можем использовать A только 1 раз

      B()
      {}
      B(A one = A())
      {
          this->one = one;
      }
  };

#+end_src

#+RESULTS:

*** DONE 30)
    CLOSED: [2021-06-15 Tue 22:24]
    Опишите два класса таким образом, чтобы они имели отношение N-арной ассоциации.
    Нарисуйте диаграмму. Поясните понятие ассоциации

Каждому объекты работник(Employee) может соответствовать несколько рабочих помещений. Мощность связи один-ко-многим.
#+begin_src C++
  class A
  {
      private:
      int i;
      public:
      A()
      {
          i = 0;
      }
  };


  class B
  {
      private:
      A *one;
      public:
      B(A *one=nullptr)
      {
          this->one = one;
      }
  };
#+end_src

#+RESULTS:
     

